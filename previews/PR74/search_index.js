var documenterSearchIndex = {"docs":
[{"location":"function_references/#QuantumCircuitOpt-Function-References","page":"Function References","title":"QuantumCircuitOpt Function References","text":"","category":"section"},{"location":"function_references/#QuantumCircuitOpt.Gate","page":"Function References","title":"QuantumCircuitOpt.Gate","text":"Gate\n\nThe struct, Gate, holds the label, the qubits and the matrix form of the gate,      primarily for post-optimization. \n\n\n\n\n\n","category":"type"},{"location":"function_references/#QuantumCircuitOpt.GateData","page":"Function References","title":"QuantumCircuitOpt.GateData","text":"GateData\n\nThe composite mutable struct, GateData, type of the gate, the complex matrix form  of the gate, full sized real form of the gate, inverse of the gate and a boolean which states if the gate has all real entries.\n\n\n\n\n\n","category":"type"},{"location":"function_references/#QuantumCircuitOpt.QCModelOptions","page":"Function References","title":"QuantumCircuitOpt.QCModelOptions","text":"QCModelOptions\n\nThe composite mutable struct, QCModelOptions, holds various optimization model options for enhancements  with defualt options set to the values provided by get_default_options function.\n\n\n\n\n\n","category":"type"},{"location":"function_references/#QuantumCircuitOpt.QuantumCircuitModel","page":"Function References","title":"QuantumCircuitOpt.QuantumCircuitModel","text":"QuantumCircuitModel\n\nThe composite mutable struct, QuantumCircuitModel, holds dictionaries for input data, abstract JuMP model for optimization, variable references and result from solving the JuMP model.\n\n\n\n\n\n","category":"type"},{"location":"function_references/#QuantumCircuitOpt.CCZGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CCZGate","text":"CCZGate()\n\nThree-qubit controlled-controlled Z gate. \n\nCircuit Representation\n\nq_0: ─■─\n      │\nq_1: ─■─\n      │\nq_2: ─■─\n\nMatrix Representation\n\nCCZGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  1  0  0  0 \n            0  0  0  0  0  1  0  0 \n            0  0  0  0  0  0  1  0 \n            0  0  0  0  0  0  0  -1 \n        endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CHGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CHGate","text":"CHGate()\n\nTwo-qubit, symmetric, controlled Hadamard gate (HGate). \n\nCircuit Representation\n\nq_0: ──■──\n     ┌─┴─┐  \nq_1: ┤ H ├    \n     └───┘\n\nMatrix Representation\n\nCH = 0ranglelangle 0 otimes I + 1ranglelangle 1 otimes H = beginpmatrix\n1  0  0  0 \n0  1  0  0 \n0  0  frac1sqrt2  frac1sqrt2 \n0  0  frac1sqrt2  -frac1sqrt2\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CHRevGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CHRevGate","text":"CHRevGate()\n\nTwo-qubit reverse controlled-H gate, with target and control on first and second qubits, respectively. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ H ├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCHRev = I otimes 0ranglelangle 0 + H otimes 1ranglelangle 1 = beginpmatrix\n        1  0  0  0 \n        0  frac1sqrt2  0  frac1sqrt2 \n        0  0  1  0 \n        0  frac1sqrt2  0  -frac1sqrt2\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CNotGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CNotGate","text":"CNotGate()\n\nTwo-qubit controlled NOT gate with control and target on first and second qubits, respectively. This is also  called the controlled X gate (CXGate). \n\nCircuit Representation\n\nq_0: ──■──\n     ┌─┴─┐\nq_1: ┤ X ├\n     └───┘\n\nMatrix Representation\n\nCNot = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CNotRevGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CNotRevGate","text":"CNotRevGate()\n\nTwo-qubit reverse controlled NOT gate, with target and control on first and second qubits, respectively. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ X ├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCNotRev = beginpmatrix\n            1  0  0  0 \n            0  0  0  1 \n            0  0  1  0 \n            0  1  0  0\n            endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CRXGate-Tuple{Number}","page":"Function References","title":"QuantumCircuitOpt.CRXGate","text":"CRXGate(θ::Number)\n\nTwo-qubit controlled RXGate. \n\nCircuit Representation\n\nq_0: ────■────\n     ┌───┴───┐\nq_1: ┤ RX(ϴ) ├\n     └───────┘\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRX(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RX(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  costh    -isinth \n        0  0  -isinth  costh\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CRXRevGate-Tuple{Number}","page":"Function References","title":"QuantumCircuitOpt.CRXRevGate","text":"CRXRevGate(θ::Number)\n\nTwo-qubit controlled reverse RXGate. \n\nCircuit Representation\n\n     ┌───────┐\nq_1: ┤ RX(ϴ) ├\n     └───┬───┘\nq_0: ────■────\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRXRev(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RX(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  costh  0  -isinth \n        0  0  1  0\n        0  -isinth  0  costh\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CRYGate-Tuple{Number}","page":"Function References","title":"QuantumCircuitOpt.CRYGate","text":"CRYGate(θ::Number)\n\nTwo-qubit controlled RYGate. \n\nCircuit Representation\n\nq_0: ────■────\n     ┌───┴───┐\nq_1: ┤ RY(ϴ) ├\n     └───────┘\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRY(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RY(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  costh    -sinth \n        0  0  sinth  costh\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CRYRevGate-Tuple{Number}","page":"Function References","title":"QuantumCircuitOpt.CRYRevGate","text":"CRYRevGate(θ::Number)\n\nTwo-qubit controlled reverse RYGate. \n\nCircuit Representation\n\n     ┌───────┐\nq_1: ┤ RY(ϴ) ├\n     └───┬───┘\nq_0: ────■────\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRYRev(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RY(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  costh  0  -sinth \n        0  0  1  0 \n        0  sinth  0  costh\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CRZGate-Tuple{Number}","page":"Function References","title":"QuantumCircuitOpt.CRZGate","text":"CRZGate(θ::Number)\n\nTwo-qubit controlled RZGate. \n\nCircuit Representation\n\nq_0: ────■────\n     ┌───┴───┐\nq_1: ┤ RZ(ϴ) ├\n     └───────┘\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRZ(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RZ(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  e^-ith    0 \n        0  0  0  e^ith\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CRZRevGate-Tuple{Number}","page":"Function References","title":"QuantumCircuitOpt.CRZRevGate","text":"CRZRevGate(θ::Number)\n\nTwo-qubit controlled reverse RZGate. \n\nCircuit Representation\n\n     ┌───────┐\nq_1: ┤ RZ(ϴ) ├\n     └───┬───┘\nq_0: ────■────\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRZRev(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RZ(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  e^-ith  0  0 \n        0  0  1   0 \n        0  0  0  e^ith\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CSGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CSGate","text":"CSGate()\n\nTwo-qubit, controlled-S gate, which induces π/2 phase in the target qubit.  This gate is invariant to the swap of control and target qubits.\n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ S ├     \n     └───┘\n\nMatrix Representation\n\nCS = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes S = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  1  0 \n        0  0  0  i\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CSXGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CSXGate","text":"CSXGate()\n\nTwo-qubit controlled version of (SXGate). \n\nCircuit Representation\n\nq_0: ─────■─────\n     ┌────┴────┐\nq_1: ┤ sqrt(X) ├\n     └─────────┘\n\nMatrix Representation\n\nCSXGate = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes SX = beginpmatrix\n1  0  0  0 \n0  1  0  0 \n0  0  05+05i  05-05i \n0  0  05-05i  05+05i\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CSXRevGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CSXRevGate","text":"CSXRevGate()\n\nTwo-qubit controlled version of the reverse (SXGate). \n\nCircuit Representation\n\n     ┌─────────┐\nq_1: ┤ sqrt(X) ├\n     └────┬────┘\nq_0: ─────■────\n\nMatrix Representation\n\nCSXRevGate = I otimes 0ranglelangle 0 + SX otimes 1ranglelangle 1 = beginpmatrix\n1  0  0  0 \n0  05+05i  0  05-05i \n0  0  1  0 \n0  05-05i  0  05+05i\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CSdaggerGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CSdaggerGate","text":"CSdaggerGate()\n\nTwo-qubit hermitian conjugate of controlled-S gate. This gate is invariant to the swap of control and target qubits.\n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ S'├     \n     └───┘\n\nMatrix Representation\n\nCSdagger = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes S^dagger = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  1  0 \n        0  0  0  -i\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CSwapGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CSwapGate","text":"CSwapGate()\n\nThree-qubit, controlled SwapGate, also known as the Fredkin gate.\n\nCircuit Representation\n\nq_0: ─■─\n      │\nq_1: ─X─\n      │\nq_2: ─X─\n\nMatrix Representation\n\nCSwapGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  1  0  0  0 \n            0  0  0  0  0  0  1  0 \n            0  0  0  0  0  1  0  0 \n            0  0  0  0  0  0  0  1 \n        endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CTGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CTGate","text":"CTGate()\n\nTwo-qubit, controlled-T gate, which induces a π/4 phase in the target qubit.  This gate is invariant to the swap of control and target qubits.\n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ T ├     \n     └───┘\n\nMatrix Representation\n\nCT = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes T = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  1  0 \n        0  0  0  e^ipi4\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CTdaggerGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CTdaggerGate","text":"CTdaggerGate()\n\nTwo-qubit hermitian conjugate of controlled-T gate. This gate is invariant to the swap of control and target qubits.\n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ T'├     \n     └───┘\n\nMatrix Representation\n\nCTdagger = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes T^dagger = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  1  0 \n        0  0  0  e^-ipi4\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CU3Gate-Tuple{Number, Number, Number}","page":"Function References","title":"QuantumCircuitOpt.CU3Gate","text":"CU3Gate(θ::Number, ϕ::Number, λ::Number)\n\nTwo-qubit, controlled version of the universal rotation gate with three Euler angles (U3Gate). \n\nCircuit Representation\n\nq_0: ──────■──────\n     ┌─────┴─────┐\nq_1: ┤ U3(ϴ,φ,λ) ├\n     └───────────┘\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCU3(theta phi lambda) q_1 q_0 =\n                0ranglelangle 0 otimes I +\n                1ranglelangle 1 otimes U3(thetaphilambda) =\n                beginpmatrix\n                    1  0    0                   0 \n                    0  1    0                   0 \n                    0  0    cos(th)           -e^ilambdasin(th) \n                    0  0    e^iphisin(th)  e^i(phi+lambda)cos(th)\n                endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CU3RevGate-Tuple{Number, Number, Number}","page":"Function References","title":"QuantumCircuitOpt.CU3RevGate","text":"CU3RevGate(θ::Number, ϕ::Number, λ::Number)\n\nTwo-qubit, reverse controlled version of the universal rotation gate with three Euler angles (U3Gate). \n\nCircuit Representation\n\n     ┌────────────┐\nq_1: ┤  U3(ϴ,φ,λ) ├\n     └──────┬─────┘\nq_0: ───────■──────\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCU3(theta phi lambda) q_1 q_0 =\n                0ranglelangle 0 otimes I +\n                1ranglelangle 1 otimes U3(thetaphilambda) =\n                beginpmatrix\n                    1  0    0   0 \n                    0  cos(th)    0  -e^ilambdasin(th) \n                    0  0     1  0 \n                    0  e^iphisin(th)   0   e^i(phi+lambda)cos(th)\n                endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CVGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CVGate","text":"CVGate()\n\nTwo-qubit, controlled-V gate, which is also the same as Controlled square-root of X gate (CSXGate).  \n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ V ├     \n     └───┘\n\nMatrix Representation\n\nCV = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  05+05i  05-05i \n        0  0  05-05i  05+05i\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CVRevGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CVRevGate","text":"CVRevGate()\n\nTwo-qubit reverse controlled-V gate, with target and control on first and second qubits, respectively. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ V ├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCVRev = beginpmatrix\n        1  0  0  0 \n        0  05+05i  0  05-05i \n        0  0  1  0 \n        0  05-05i  0  05+05i\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CVdaggerGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CVdaggerGate","text":"CVdaggerGate()\n\nTwo-qubit hermitian conjugate of controlled-V gate, which is also the same as hermitian conjugate Controlled square-root of X gate (CSXGate).  \n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ V'├     \n     └───┘\n\nMatrix Representation\n\nCVdagger = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  05-05i  05+05i \n        0  0  05+05i  05-05i\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CVdaggerRevGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CVdaggerRevGate","text":"CVdaggerRevGate()\n\nTwo-qubit hermitian conjugate of reverse controlled-V gate, with target and control on first and second qubits, respectively. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ V'├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCVdaggerRev = beginpmatrix\n        1  0  0  0 \n        0  05-05i  0  05+05i \n        0  0  1  0 \n        0  05+05i  0  05-05i\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CXGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CXGate","text":"CXGate()\n\nTwo-qubit controlled XGate, which is also the same as CNotGate. \n\nCircuit Representation\n\nq_0: ──■──\n     ┌─┴─┐\nq_1: ┤ X ├\n     └───┘\n\nMatrix Representation\n\nCX = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CXRevGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CXRevGate","text":"CXRevGate()\n\nTwo-qubit reverse controlled-X gate, with target and control on first and second qubits, respectively.  This is also the same as CNotRevGate. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ X ├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCXRev = I otimes 0 ranglelangle 0 + X otimes 1 ranglelangle 1 = beginpmatrix\n        1  0  0  0 \n        0  0  0  1 \n        0  0  1  0 \n        0  1  0  0\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CYGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CYGate","text":"CYGate()\n\nTwo-qubit controlled YGate. \n\nCircuit Representation\n\nq_0: ──■──\n     ┌─┴─┐\nq_1: ┤ Y ├\n     └───┘\n\nMatrix Representation\n\nCY = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes Y = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  -i \n    0  0  i  0\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CYRevGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CYRevGate","text":"CYRevGate()\n\nTwo-qubit reverse controlled-Y gate, with target and control on first and second qubits, respectively. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ Y ├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCYRev = I otimes 0 ranglelangle 0 + Y otimes 1 ranglelangle 1 = beginpmatrix\n        1  0  0  0 \n        0  0  0  -i \n        0  0  1  0 \n        0  i  0  0\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CZGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CZGate","text":"CZGate()\n\nTwo-qubit, symmetric, controlled ZGate. \n\nCircuit Representation\n\nq_0: ──■──     ─■─\n     ┌─┴─┐  ≡   │\nq_1: ┤ Z ├     ─■─\n     └───┘\n\nMatrix Representation\n\nCZ = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes Z = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.CiSwapGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.CiSwapGate","text":"CiSwapGate()\n\nThree-qubit controlled version of the iSwapGate. Reference: https://doi.org/10.1103/PhysRevResearch.2.033097\n\nCircuit Representation\n\nq_0: ─────■─────\n          │\n      ┌───────┐\nq_1: ─┤       ├─\n      │ iSwap │   \nq_2: ─┤       ├─ \n      └───────┘ \n\nMatrix Representation\n\nCiSwapGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  1  0  0  0 \n            0  0  0  0  0  0  i  0 \n            0  0  0  0  0  i  0  0 \n            0  0  0  0  0  0  0  1 \n        endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.DCXGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.DCXGate","text":"DCXGate()\n\nTwo-qubit double controlled NOT gate consisting of two back-to-back CNotGates with alternate controls. \n\nCircuit Representation\n\n          ┌───┐\nq_0: ──■──┤ X ├\n     ┌─┴─┐└─┬─┘\nq_1: ┤ X ├──■──\n     └───┘\n\nMatrix Representation\n\nDCX = beginpmatrix\n    1  0  0  0 \n    0  0  0  1 \n    0  1  0  0 \n    0  0  1  0\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.GRGate-Tuple{Int64, Number, Number}","page":"Function References","title":"QuantumCircuitOpt.GRGate","text":"GRGate(num_qubits::Int64, θ::Number, ϕ::Number)\n\nA multi-qubit rotation gate with two Euler angles, theta and phi,  applied about the cos(phi)x + sin(phi)y axis and parametrized by the number of qubits.  This gate can be applied to multiple qubits simultaneously, for a given depth.  The global R gate is native to atomic systems. In the one-qubit case, this gate is  equivalent to the RGate.\n\nReference: Qiskit's circuit library\n\nCircuit Representation (in 3 qubits)\n\n     ┌──────────┐\nq_0: ┤0         ├ \n     │          │\nq_1: ┤1 GR(ϴ,φ) ├    \n     │          │\nq_2: ┤2         ├\n     └──────────┘\n\nMatrix Representation (in 3 qubits)\n\nGR(theta phi) = exp left(-i sum_i=1^3 (cos(phi)X_i + sin(phi)Y_i) theta2 right)  \n                 = R(theta phi) otimes R(theta phi) otimes R(theta phi)  \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.GroverDiffusionGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.GroverDiffusionGate","text":"GroverDiffusionGate()\n\nTwo-qubit, Grover's diffusion operator, a key building block of the Glover's algorithm used to find a specific item (with probability > 0.5) within a randomly ordered database of N items in O(sqrt(N)) operations.  Reference: https://arxiv.org/pdf/1804.03719.pdf\n\nMatrix Representation\n\nGroverDiffusionGate = frac12beginpmatrix\n1  -1  -1  -1 \n-1  1  -1  -1 \n-1  -1  1  -1  \n-1  -1  -1  1\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.HCoinGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.HCoinGate","text":"HCoinGate()\n\nTwo-qubit, Hadamard Coin gate when implemented in tune with the quantum cellular automata.  Reference: https://doi.org/10.1007/s11128-018-1983-x, https://arxiv.org/pdf/2106.03115.pdf\n\nMatrix Representation\n\nHCoinGate = beginpmatrix\n1  0  0  0 \n0  frac1sqrt2  frac1sqrt2  0 \n0  frac1sqrt2  -frac1sqrt2  0 \n0  0  0  1\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.HGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.HGate","text":"HGate()\n\nSingle-qubit Hadamard gate, which is a pi rotation about the X+Z axis, thus equivalent to U3Gate(fracpi20pi)\n\nMatrix Representation\n\nH = frac1sqrt2\n        beginpmatrix\n            1  1 \n            1  -1\n        endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.IGate-Tuple{Int64}","page":"Function References","title":"QuantumCircuitOpt.IGate","text":"IGate(num_qubits::Int64)\n\nIdentity matrix for an input number of qubits.\n\nMatrix Representation (num_qubits = 1)\n\nI = beginpmatrix\n        1  0 \n        0  1\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.MGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.MGate","text":"MGate()\n\nTwo-qubit Magic gate, also known as the Ising coupling or the XX gate.\n\nReference: https://doi.org/10.1103/PhysRevA.69.032315\n\nCircuit Representation\n\n      ┌───┐        ┌───┐\nq_0: ─┤ X ├────────┤ S ├\n      └─┬─┘        └─┬─┘        \n        │   ┌───┐  ┌─┴─┐\nq_1: ───■───┤ H ├──┤ S ├\n            └───┘  └───┘\n\nMatrix Representation\n\nM = frac1sqrt2 beginpmatrix\n1  i  0  0 \n0  0  i  1 \n0  0  i  -1 \n1  -i  0  0\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.MargolusGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.MargolusGate","text":"MargolusGate()\n\nThree-qubit Margolus gate, which is a simplified ToffoliGate and coincides with the Toffoli gate up  to a single change of sign. The advantage of this gate is that its implementation requires only three CNot (or CX) gates.  Reference: https://arxiv.org/pdf/quant-ph/0312225.pdf\n\nMatrix Representation\n\nMargolusGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  1  0  0  0 \n            0  0  0  0  0  -1  0  0 \n            0  0  0  0  0  0  0  1 \n            0  0  0  0  0  0  1  0 \n        endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.PeresGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.PeresGate","text":"PeresGate()\n\nThree-qubit Peres gate. This gate is equivalent to ToffoliGate followed by the CNotGate in 3 qubits.  Reference: https://doi.org/10.1103/PhysRevA.32.3266\n\nCircuit Representation\n\nq_0: ──■─────■──          \n       │   ┌─┴─┐\nq_1: ──■───┤ X ├\n     ┌─┴─┐ └───┘\nq_2: ┤ X ├──────\n     └───┘\n\nMatrix Representation\n\nPeresGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  0  0  1  0 \n            0  0  0  0  0  0  0  1 \n            0  0  0  0  0  1  0  0 \n            0  0  0  0  1  0  0  0 \n        endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.PhaseGate-Tuple{Number}","page":"Function References","title":"QuantumCircuitOpt.PhaseGate","text":"PhaseGate(λ::Number)\n\nSingle-qubit rotation gate about the Z axis. This is also equivalent to U3Gate(00lambda). This  gate is also referred to as the U1Gate. \n\nMatrix Representation\n\nP(lambda) = beginpmatrix\n    1  0 \n    0  e^ilambda\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.QFT2Gate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.QFT2Gate","text":"QFT2Gate()\n\nTwo-qubit Quantum Fourier Transform (QFT) gate, where the QFT operation on n-qubits is given by: \n\njrangle mapsto frac12^n2 sum_k=0^2^n - 1 e^2pi ijk  2^n krangle\n\nCircuit Representation\n\n     ┌──────┐\nq_0: ┤      ├\n     │ QFT2 │   \nq_1: ┤      ├ \n     └──────┘ \n\nMatrix Representation\n\nM = frac12 beginpmatrix\n1  1  1  1 \n1  i  -1  -i \n1  -1  1  -1 \n1  -i  -1  i\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.QFT3Gate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.QFT3Gate","text":"QFT3Gate()\n\nThree-qubit Quantum Fourier Transform (QFT) gate, where the QFT operation on n-qubits is given by: \n\njrangle mapsto frac12^n2 sum_k=0^2^n - 1 e^2pi ijk  2^n krangle\n\nCircuit Representation\n\n     ┌──────┐\nq_0: ┤      ├\n     │      │   \nq_1: ┤ QFT3 ├ \n     │      │   \nq_3: ┤      ├ \n     └──────┘ \n\nMatrix Representation\n\nM = frac12sqrt2 beginpmatrix\n1   1        1        1        1   1        1        1  \n1       frac1sqrt2 + fracisqrt2            i      -frac1sqrt2 + fracisqrt2      -1      -frac1sqrt2 - fracisqrt2            -i       frac1sqrt2 - fracisqrt2  \n1        i  -1             -i   1        i  -1             -i  \n1      -frac1sqrt2 + fracisqrt2            -i       frac1sqrt2 + fracisqrt2      -1       frac1sqrt2 - fracisqrt2            i      -frac1sqrt2 - fracisqrt2  \n1  -1        1       -1        1  -1        1       -1  \n1      -frac1sqrt2 - fracisqrt2            i       frac1sqrt2 - fracisqrt2      -1       frac1sqrt2 + fracisqrt2            -i      -frac1sqrt2 + fracisqrt2  \n1        -i  -1             i   1        -i  -1             i  \n1       frac1sqrt2 - fracisqrt2            -i      -frac1sqrt2 - fracisqrt2      -1      -frac1sqrt2 + fracisqrt2            i       frac1sqrt2 + fracisqrt2  \nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.RCCXGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.RCCXGate","text":"RCCXGate()\n\nThree-qubit relative (or simplified) Toffoli gate, or the CCX gate. This gate is equivalent to ToffoliGate upto relative phases.  The advantage of this gate is that it's implementation requires only three CNot (or CX) gates.  Reference: https://arxiv.org/pdf/1508.03273.pdf\n\nMatrix Representation\n\nRCCXGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  1  0  0  0 \n            0  0  0  0  0  -1  0  0 \n            0  0  0  0  0  0  0  -i \n            0  0  0  0  0  0  i  0 \n        endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.RGate-Tuple{Number, Number}","page":"Function References","title":"QuantumCircuitOpt.RGate","text":"RGate(θ::Number, ϕ::Number)\n\nA single-qubit rotation gate with two Euler angles, theta and phi,  about the cos(phi)x + sin(phi)y axis. \n\nMatrix Representation\n\nR(theta phi) =  e^-i theta left(cosphi x + sinphi yright) =\nbeginpmatrix\n    costheta  -i e^-i phi sintheta \n    -i e^i phi sintheta  costheta\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.RXGate-Tuple{Number}","page":"Function References","title":"QuantumCircuitOpt.RXGate","text":"RXGate(θ::Number)\n\nA single-qubit Pauli gate which represents rotation about the X axis.\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nRX(theta) = exp(-i th X) =\n    beginpmatrix\n        costh    -isinth \n        -isinth  costh\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.RYGate-Tuple{Number}","page":"Function References","title":"QuantumCircuitOpt.RYGate","text":"RYGate(θ::Number)\n\nA single-qubit Pauli gate which represents rotation about the Y axis.\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nRY(theta) = exp(-i th Y) =\n    beginpmatrix\n        costh  -sinth \n        sinth  costh\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.RZGate-Tuple{Number}","page":"Function References","title":"QuantumCircuitOpt.RZGate","text":"RZGate(θ::Number)\n\nA single-qubit Pauli gate which represents rotation about the Z axis. This gate is also equivalent to U1Gate up to a phase factor,  that is, RZ(theta) = e^-itheta2U1(theta).\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nRZ(theta) = exp(-ith Z) =\nbeginpmatrix\n    e^-ith  0 \n    0  e^ith\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.SGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.SGate","text":"SGate()\n\nSingle-qubit S gate, equivalent to U3Gate(00fracpi2). This  gate is also referred to as a Clifford gate, P gate or a square-root of Pauli-ZGate. Historically, this is also  called as the phase gate (denoted by P), since it shifts the phase of the one state relative to the zero state.\n\nMatrix Representation\n\nS = beginpmatrix\n1  0 \n0  i\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.SSwapGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.SSwapGate","text":"SSwapGate()\n\nTwo-qubit, square root version of the SwapGate. \n\nCircuit Representation\n\n     ┌────────────┐\nq_0: ┤            ├\n     │ sqrt(Swap) │   \nq_1: ┤            ├ \n     └────────────┘ \n\nMatrix Representation\n\nSWAP = beginpmatrix\n1  0  0  0 \n0  05+05i  05-05i  0 \n0  05-05i  05+05i  0 \n0  0  0  1\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.SXGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.SXGate","text":"SXGate()\n\nSingle-qubit square root of pauli-XGate.\n\nMatrix Representation\n\nsqrtX = frac12 beginpmatrix\n1 + i  1 - i \n1 - i  1 + i\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.SXdaggerGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.SXdaggerGate","text":"SXdaggerGate()\n\nSingle-qubit hermitian conjugate of the square root of pauli-XGate, or the SXGate.\n\nMatrix Representation\n\nsqrtX^dagger = frac12 beginpmatrix\n1 - i  1 + i \n1 + i  1 - i\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.SdaggerGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.SdaggerGate","text":"SdaggerGate()\n\nSingle-qubit, hermitian conjugate of the SGate. This is also an alternative square root of  the ZGate. \n\nMatrix Representation\n\nS = beginpmatrix\n1  0 \n0  -i\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.SwapGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.SwapGate","text":"SwapGate()\n\nTwo-qubit, symmetric, SWAP gate. \n\nCircuit Representation\n\nq_0: ─X─\n      │\nq_1: ─X─\n\nMatrix Representation\n\nSWAP = beginpmatrix\n1  0  0  0 \n0  0  1  0 \n0  1  0  0 \n0  0  0  1\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.SycamoreGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.SycamoreGate","text":"SycamoreGate()\n\nTwo-qubit Sycamore Gate, native to Google's universal quantum processor. Reference: quantumai.google/cirq/google/devices\n\nCircuit Representation\n\n     ┌──────┐\nq_0: ┤      ├\n     │ SYC  │   \nq_1: ┤      ├ \n     └──────┘ \n\nMatrix Representation\n\n\nSycamoreGate() = beginpmatrix\n1  0  0  0 \n0  0  -i  0 \n0  -i  0  0  \n0  0  0  e^-i fracpi6\nendpmatrix\n\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.TGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.TGate","text":"TGate()\n\nSingle-qubit T gate, equivalent to U3Gate(00fracpi4). This  gate is also referred to as a fracpi8 gate or as a fourth-root of Pauli-ZGate. \n\nMatrix Representation\n\nT = beginpmatrix\n1  0 \n0  e^ipi4\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.TdaggerGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.TdaggerGate","text":"TdaggerGate()\n\nSingle-qubit, hermitian conjugate of the TGate. This gate is equivalent to U3Gate(00-fracpi4). This  gate is also referred to as the fourth-root of Pauli-ZGate. \n\nMatrix Representation\n\nT^dagger = beginpmatrix\n1  0 \n0  e^-ipi4\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.ToffoliGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.ToffoliGate","text":"ToffoliGate()\n\nThree-qubit Toffoli gate, also known as the CCX (controlled-controlled-NOT) gate. \n\nCircuit Representation\n\nq_0: ──■──\n       │\nq_1: ──■──\n     ┌─┴─┐\nq_2: ┤ X ├\n     └───┘\n\nMatrix Representation\n\nToffoli     =\n            0 rangle langle 0 otimes I otimes I + 1 rangle langle 1 otimes CXGate =\n            beginpmatrix\n                1  0  0  0  0  0  0  0\n                0  1  0  0  0  0  0  0\n                0  0  1  0  0  0  0  0\n                0  0  0  1  0  0  0  0\n                0  0  0  0  1  0  0  0\n                0  0  0  0  0  1  0  0\n                0  0  0  0  0  0  0  1\n                0  0  0  0  0  0  1  0\n            endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.U1Gate-Tuple{Number}","page":"Function References","title":"QuantumCircuitOpt.U1Gate","text":"U1Gate(λ::Number)\n\nUniversal single-qubit rotation gate with one Euler angle, lambda. U1Gate represents rotation about the Z axis and  is the special case of U3Gate, which also known as the PhaseGate. Also note that U1(pi) =ZGate, U1(pi2) =SGate and  U1(pi4) =TGate.\n\nMatrix Representation\n\nU1(lambda) =\nbeginpmatrix\n    1  0 \n    0  e^ilambda\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.U2Gate-Tuple{Number, Number}","page":"Function References","title":"QuantumCircuitOpt.U2Gate","text":"U2Gate(ϕ::Number, λ::Number)\n\nUniversal single-qubit rotation gate with two Euler angles, phi and lambda. U2Gate is the special case of  U3Gate. \n\nMatrix Representation\n\nU2(phi lambda) = frac1sqrt2\nbeginpmatrix\n    1           -e^ilambda \n    e^iphi  e^i(phi+lambda)\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.U3Gate-Tuple{Number, Number, Number}","page":"Function References","title":"QuantumCircuitOpt.U3Gate","text":"U3Gate(θ::Number, ϕ::Number, λ::Number)\n\nUniversal single-qubit rotation gate with three Euler angles, theta, phi and lambda.\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nU3(theta phi lambda) =\n    beginpmatrix\n        cos(th)           -e^ilambdasin(th) \n        e^iphisin(th)  e^i(phi+lambda)cos(th)\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.WGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.WGate","text":"WGate()\n\nTwo-qubit, W hermitian gate, typically useful to diagonlize the (SwapGate).  \n\nMatrix Representation\n\nW = beginpmatrix\n        1  0  0  0 \n        0  frac1sqrt2  frac1sqrt2  0 \n        0  frac1sqrt2  -frac1sqrt2  0 \n        0  0  0  1\n    endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.XGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.XGate","text":"XGate()\n\nSingle-qubit Pauli-X gate (sigma_x), equivalent to U3Gate(pi0pi)\n\nMatrix Representation\n\nX = beginpmatrix\n0  1 \n1  0\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.YGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.YGate","text":"YGate()\n\nSingle-qubit Pauli-Y gate (sigma_y), equivalent to U3Gate(pifracpi2fracpi2)\n\nMatrix Representation\n\nY = beginpmatrix\n0  -i \ni  0\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.ZGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.ZGate","text":"ZGate()\n\nSingle-qubit Pauli-Z gate (sigma_z), equivalent to U3Gate(00pi)\n\nMatrix Representation\n\nZ = beginpmatrix\n1  0 \n0  -1\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt._catch_gate_name_error-Tuple{}","page":"Function References","title":"QuantumCircuitOpt._catch_gate_name_error","text":"_catch_gate_name_error()\n\nHelper function to ensure that the kron_symbol x does not appear in any of the gate names. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt._catch_input_gate_errors-Tuple{String, Vector{Int64}, Int64, String}","page":"Function References","title":"QuantumCircuitOpt._catch_input_gate_errors","text":"_catch_input_gate_errors(gate_type::String, qubit_loc::Vector{Int64}, num_qubits::Int64, input_gate::String)\n\nGiven an input gate string, number of qubits of the circuit and the qubit locations for the input gate,  this function catches and throws any errors, should the input gate type and qubits are invalid. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt._determinant_test_for_infeasibility-Tuple{Dict{String, Any}}","page":"Function References","title":"QuantumCircuitOpt._determinant_test_for_infeasibility","text":"_determinant_test_for_infeasibility(data::Dict{String,Any})\n\nThis function performs determinant-based checks on the target and elementary gates in the given      data dictionary to detect potential MIP infeasibility.\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt._get_constraint_slope_intercept-Tuple{Tuple{Number, Number}, Tuple{Number, Number}}","page":"Function References","title":"QuantumCircuitOpt._get_constraint_slope_intercept","text":"_get_constraint_slope_intercept(vertex1::Vector{<:Number}, vertex2::Vector{<:Number})\n\nGiven co-ordinates of two points in a plane, this function returns the slope (m) and intercept (c) of the  line joining these two points. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt._get_elementary_gates_fixed_indices-Tuple{Array{T, 3} where T<:Number}","page":"Function References","title":"QuantumCircuitOpt._get_elementary_gates_fixed_indices","text":"_get_elementary_gates_fixed_indices(M::Array{T,3} where T <: Number)\n\nGiven the set of input elementary gates in real form,  this function returns a dictionary of tuples of indices wholse values are fixed in sum_k (z_k*M[:,:,k]). \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt._get_matrix_product_fixed_indices-Tuple{Dict{Tuple{Int64, Int64}, Any}, Dict{Tuple{Int64, Int64}, Any}, Int64}","page":"Function References","title":"QuantumCircuitOpt._get_matrix_product_fixed_indices","text":"_get_matrix_product_fixed_indices(left_matrix_fixed_idx::Dict{Tuple{Int64, Int64}, Any}, \n                              right_matrix_fixed_idx::Dict{Tuple{Int64, Int64}, Any}, \n                              N::Int64)\n\nGiven left and right square matrices of size NxN, in a dictionary format with tuples of indices whose values are fixed,  this function returns a dictionary of tuples of indices wholse values are fixed in left_matrix * right_matrix. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt._get_nonzero_idx_of_complex_matrix-Tuple{Matrix{ComplexF64}}","page":"Function References","title":"QuantumCircuitOpt._get_nonzero_idx_of_complex_matrix","text":"_get_nonzero_idx_of_complex_matrix(M::Array{Complex{Float64},2})\n\nA helper function for global phase constraints: Given a complex matrix, M, this  function returns the first non-zero index it locates within M, either in real or the complex part. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt._get_nonzero_idx_of_complex_to_real_matrix-Tuple{Matrix{Float64}}","page":"Function References","title":"QuantumCircuitOpt._get_nonzero_idx_of_complex_to_real_matrix","text":"_get_nonzero_idx_of_complex_to_real_matrix(M::Array{Float64,2})\n\nA helper function for global phase constraints: Given a complex to real reformulated matrix, M, using QCO.complex_to_real_gate, this function  returns the first non-zero index it locates within M. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt._get_unitary_variables_fixed_indices-Tuple{Array{T, 3} where T<:Number, Int64}","page":"Function References","title":"QuantumCircuitOpt._get_unitary_variables_fixed_indices","text":"_get_unitary_variables_fixed_indices(M::Array{T,3} where T <: Number, \n                                     maximum_depth::Int64)\n\nGiven a 3D array of real square matrices (representing gates), and a maximum alowable depth,  this function returns a dictionary of tuples of indices wholse values are fixed in the unitary matrices for every depth  of the circuit. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt._parse_gate_string-Tuple{String}","page":"Function References","title":"QuantumCircuitOpt._parse_gate_string","text":"_parse_gate_string(s::String)\n\nGiven a string representing a single gate with qubit numbers separated by symbol _, this  function parses and returns the vector of qubits on which the input gate is located. For example,  if the input string is CRX_2_3, the output will be Vector{Int64}([2,3]).\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt._parse_gates_with_kron_symbol-Tuple{String}","page":"Function References","title":"QuantumCircuitOpt._parse_gates_with_kron_symbol","text":"_parse_gates_with_kron_symbol(s::String)\n\nGiven a string with gates separated by kronecker symbols x, this function parses and returns the vector of gates. For  example, if the input string is H_1xCNot_2_3xT_4, the output will be Vector{String}([\"H_1\", \"CNot_2_3\", \"T_4\"]).\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.auxiliary_variable_bounds-Tuple{Vector{JuMP.VariableRef}}","page":"Function References","title":"QuantumCircuitOpt.auxiliary_variable_bounds","text":"auxiliary_variable_bounds(v::Array{JuMP.VariableRef,1})\n\nGiven a vector of JuMP variables (maximum 4 variables), this function returns the worst-case  bounds, the product of these input variables can admit.  \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.build_QCModel_result-Tuple{QuantumCircuitModel, Number}","page":"Function References","title":"QuantumCircuitOpt.build_QCModel_result","text":"\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.circuit_unitary-Tuple{Vector{Vector{QuantumCircuitOpt.Gate}}}","page":"Function References","title":"QuantumCircuitOpt.circuit_unitary","text":"circuit_unitary(layers::Vector{Vector{Gate}})\n\nReturns the overall unitary matrix representing a quantum circuit by multiplying the unitary matrices of each layer (left to right).\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.complex_to_real_gate-Tuple{Matrix{ComplexF64}}","page":"Function References","title":"QuantumCircuitOpt.complex_to_real_gate","text":"complex_to_real_gate(M::Array{Complex{Float64},2})\n\nGiven a complex-valued two-dimensional quantum gate of size NxN, this function returns a real-valued gate  of dimensions 2Nx2N. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.compress_circuit-Tuple{Vector{QuantumCircuitOpt.Gate}, Int64}","page":"Function References","title":"QuantumCircuitOpt.compress_circuit","text":"compress_circuit(gates::Vector{Gate}, num_qubits::Int)\n\nThis function compresses a quantum circuit by placing gates into the earliest possible layer where  they can be executed in parallel. Gates can be placed in the same layer if they operate on disjoint  sets of qubits. If no suitable layer is found, a new layer is created. This function reduces  circuit depth while preserving the total number of gates and the logical operation.\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.eliminate_nonunique_gates-Tuple{Dict{String, Any}, Bool}","page":"Function References","title":"QuantumCircuitOpt.eliminate_nonunique_gates","text":"eliminate_nonunique_gates(gates_dict::Dict{String, Any})\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.fSwapGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.fSwapGate","text":"fSwapGate()\n\nTwo-qubit, symmetric, Fermionic SWAP gate, that swaps adjacent fermionic modes  in the Jordan-Wigner representation. Because the qubits represent identical  fermions, swapping two particles applies a -1 phase to the state.\n\nReference: https://doi.org/10.22331/q-2018-12-21-114\n\nMatrix Representation\n\nfSWAP = beginpmatrix\n1  0  0  0 \n0  0  1  0 \n0  1  0  0 \n0  0  0  -1\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.gate_element_bounds-Tuple{Array{Float64, 3}}","page":"Function References","title":"QuantumCircuitOpt.gate_element_bounds","text":"gate_element_bounds(M::Array{Float64,3})\n\nGiven a set of elementary gates, {G1, G2, ... ,Gn}, this function evaluates  the range of every co-ordinate of the superimposed gates, over all possible gates.  \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.get_commutative_gate_pairs-Tuple{Dict{String, Any}, String}","page":"Function References","title":"QuantumCircuitOpt.get_commutative_gate_pairs","text":"get_commutative_gate_pairs(M::Dict{String,Any}; decomposition_type::String; identity_in_pairs = true)\n\nGiven a dictionary of elementary quantum gates, this function returns all pairs of commuting  gates. Optional argument, identity_pairs can be set to false if identity matrix need not be part of the commuting pairs. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.get_data-Tuple{Dict{String, Any}}","page":"Function References","title":"QuantumCircuitOpt.get_data","text":"get_data(params::Dict{String, Any}; eliminate_identical_gates = true)\n\nGiven the user input params dictionary, this function returns a dictionary of processed data which contains all the  necessary information to formulate the optimization model for the circuit design problem. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.get_default_options-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.get_default_options","text":"get_default_options()\n\nThis function returns the default options for building the struct QCModelOptions.\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.get_full_sized_kron_gate-Tuple{String, Int64}","page":"Function References","title":"QuantumCircuitOpt.get_full_sized_kron_gate","text":"get_full_sized_kron_gate(input::String, num_qubits::Int64)\n\nGiven an input string with kronecker symbols representing the gate and number of qubits of  the circuit, this function returns a full-sized gate with respect to the input number of qubits.  For example, if num_qubits = 3 and the input gate in I_1xT_2xH_3, then this function returns  IGate⨂TGate⨂HGate, where IGate, TGate and HGate are single-qubit Identity, T and  Hadamard gates, respectively. Two qubit gates can also be used as one of the input gates, for ex. I_1xCV_2_3xH_4.  Note that this function currently does not support an input gate parametrized with Euler angles.\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.get_idempotent_gates-Tuple{Dict{String, Any}, String}","page":"Function References","title":"QuantumCircuitOpt.get_idempotent_gates","text":"get_idempotent_gates(M::Dict{String,Any}, decomposition_type::String)\n\nGiven the dictionary of complex quantum gates, this function returns the indices of matrices which are self-idempotent  or idempotent with other set of input gates, excluding the Identity gate.\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.get_input_circuit_dict-Tuple{Vector{Tuple{Int64, String}}, Dict{String, Any}}","page":"Function References","title":"QuantumCircuitOpt.get_input_circuit_dict","text":"get_input_circuit_dict(input_circuit::Vector{Tuple{Int64,String}}, params::Dict{String,Any})\n\nGiven the user input circuit which serves as a warm-start to the optimization model, and user input params dictionary,  this function outputs the post-processed dictionary of the input circuit which is used by the optimization model. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.get_involutory_gates-Tuple{Dict{String, Any}}","page":"Function References","title":"QuantumCircuitOpt.get_involutory_gates","text":"get_involutory_gates(M::Dict{String,Any})\n\nGiven the dictionary of complex gates G_1, G_2, ..., G_n, this function returns the indices of these gates  which are involutory, i.e, G_i^2 = Identity, excluding the Identity gate. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.get_objective_bound-Tuple{JuMP.Model}","page":"Function References","title":"QuantumCircuitOpt.get_objective_bound","text":"\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.get_objective_value-Tuple{JuMP.Model}","page":"Function References","title":"QuantumCircuitOpt.get_objective_value","text":"\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.get_redundant_gate_product_pairs-Tuple{Dict{String, Any}, String}","page":"Function References","title":"QuantumCircuitOpt.get_redundant_gate_product_pairs","text":"get_redundant_gate_product_pairs(M::Dict{String,Any}, decomposition_type::String)\n\nGiven a dictionary of elementary quantum gates, this function returns all pairs of gates whose product is  one of the input elementary gates. For example, let G_basis = {G1, G2, G3} be the elementary gates. If G1*G2 ∈ G_basis,  then (1,2) is considered as a redundant pair. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.get_target_gate-Tuple{Dict{String, Any}, Bool, String}","page":"Function References","title":"QuantumCircuitOpt.get_target_gate","text":"get_target_gate(params::Dict{String, Any}, are_elementary_gates_real::Bool)\n\nGiven the user input params dictionary and a boolean if all the input elementary gates are real,  this function returns the corresponding real version of the target gate. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.iSwapGate-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.iSwapGate","text":"iSwapGate()\n\nTwo-qubit, symmetric and clifford, iSWAP gate. This is an entangling swapping gate where the qubits  obtain a phase of i if the state of the qubits is swapped.\n\nCircuit Representation\n\nq_0: ─⨂─\n      │     \nq_1: ─⨂─    \n\nMinimum depth representation\n\n      ┌───┐     ┌───┐ ┌───┐\nq_0: ─┤ X ├──■──┤ S ├─┤ X ├─\n      └─┬─┘┌─┴─┐└───┘ └─┬─┘\nq_1: ───■──┤ X ├────────■──\n           └───┘\n\nMatrix Representation\n\niSWAP = beginpmatrix\n1  0  0  0 \n0  0  i  0 \n0  i  0  0 \n0  0  0  1\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.is_gate_real-Tuple{Matrix{ComplexF64}}","page":"Function References","title":"QuantumCircuitOpt.is_gate_real","text":"is_gate_real(M::Array{Complex{Float64},2})\n\nGiven a complex-valued quantum gate, M, this function returns if M has purely real parts or not as it's elements. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.isapprox_global_phase-Tuple{Matrix{ComplexF64}, Matrix{ComplexF64}}","page":"Function References","title":"QuantumCircuitOpt.isapprox_global_phase","text":"isapprox_global_phase(M1::Array{Complex{Float64},2}, M2::Array{Complex{Float64},2}; tol_0 = 1E-4)\n\nGiven two complex matrices, M1 and M2, this function returns a boolean if these matrices are  equivalent up to a global phase. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.kron_layer-Tuple{Vector{QuantumCircuitOpt.Gate}, Int64}","page":"Function References","title":"QuantumCircuitOpt.kron_layer","text":"kron_layer(layer::Vector{Gate}, num_qubits::Int)::String\n\nConverts a layer of quantum gates into a human-readable string representation. The function formats the layer as a tensor product (⊗) of gates, with identity gates (I) inserted for qubits that don't have an explicit gate in the layer.\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.kron_single_qubit_gate-Tuple{Int64, Matrix{ComplexF64}, String}","page":"Function References","title":"QuantumCircuitOpt.kron_single_qubit_gate","text":"kron_single_qubit_gate(num_qubits::Int64, M::Array{Complex{Float64},2}, qubit_loc::String)\n\nGiven number of qubits of the circuit, the complex-valued one-qubit gate and the qubit location (\"q1\",\"q2',\"q3\",...), this function returns a full-sized gate after applying appropriate kronecker products. This function supports any number  integer-valued qubits.  \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.kron_two_qubit_gate-Tuple{Int64, Matrix{ComplexF64}, String, String}","page":"Function References","title":"QuantumCircuitOpt.kron_two_qubit_gate","text":"kron_two_qubit_gate(num_qubits::Int64, M::Array{Complex{Float64},2}, c_qubit_loc::String, t_qubit_loc::String)\n\nGiven number of qubits of the circuit, the complex-valued two-qubit gate and the control and  target qubit locations (\"q1\",\"q2',\"q3\",...), this function returns a full-sized gate after applying  appropriate kronecker products. This function supports any number of integer-valued qubits.  \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.logger_config!-Tuple{Any}","page":"Function References","title":"QuantumCircuitOpt.logger_config!","text":"allows the user to set the logging level without the need to add Memento\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.multi_controlled_gate-Tuple{Matrix{ComplexF64}, Vector{Int64}, Int64, Int64}","page":"Function References","title":"QuantumCircuitOpt.multi_controlled_gate","text":"multi_controlled_gate(target_gate::Array{Complex{Float64},2}, \n                      control_qubits::Vector{Int64}, \n                      target_qubit::Int64, \n                      num_qubits::Int64)\n\nGiven a single-qubit complex-valued target gate, a vector of control qubits (control_qubits), and a target qubit,  this function returns a complex-valued multi-controlled gate (MCT) representable in num_qubits.  The states of control qubits can be any wire preceeding or succeeding the location  of the input gate's target qubit. Here are a few examples: (a) ToffoliGate = multicontrolledgate(XGate(), [1,2], 3, 3) (b) Reverse ToffoliGate with one ancilla = multicontrolledgate(XGate(), [2,3], 1, 4) (c) CHRevGate = multicontrolledgate(HGate(), [2], 1, 2) (d) CCZGate = multicontrolledgate(ZGate(), [1,2], 3, 3) (e) CU3Gate(θ,ϕ,λ) = multicontrolledgate(U3Gate(θ,ϕ,λ), [1], 2, 2)\n\nNotes: For any single qubit target gate, an MCT gate, controlled off 𝑖 and targeting 𝑗, is given by 1^⊗𝑁 + 1⊗(𝑖−1) ⊗ |1⟩⟨1| ⊗ {1^⊗(𝑗−𝑖−1)} ⊗ (target_gate − I^⊗1) ⊗ {1^⊗(𝑁−𝑗)}\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.multi_qubit_global_gate-Tuple{Int64, Matrix{ComplexF64}}","page":"Function References","title":"QuantumCircuitOpt.multi_qubit_global_gate","text":"multi_qubit_global_gate(num_qubits::Int64, M::Array{Complex{Float64},2})\n\nGiven number of qubits of the circuit and any complex-valued one-qubit gate (G) in it's matrix form, this function returns a multi-qubit global gate, by applyingGsimultaneously on all the qubits.  For example, givenGandnum_qubits = 3, this function returnsG⨂G⨂G`. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.optimize_QCModel!-Tuple{QuantumCircuitModel}","page":"Function References","title":"QuantumCircuitOpt.optimize_QCModel!","text":"\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.print_circuit-Tuple{Vector{Vector{QuantumCircuitOpt.Gate}}, Int64}","page":"Function References","title":"QuantumCircuitOpt.print_circuit","text":"print_circuit(circuit_layers::Vector{Vector{Gate}}, num_qubits::Int)\n\nPrint a quantum circuit in a human-readable format, showing each layer of gates.\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.real_to_complex_gate-Tuple{Matrix{Float64}}","page":"Function References","title":"QuantumCircuitOpt.real_to_complex_gate","text":"real_to_complex_gate(M::Array{Complex{Float64},2})\n\nGiven a real-valued two-dimensional quantum gate of size 2Nx2N, this function returns a complex-valued gate  of size NxN, if the input gate is in a valid complex form. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.relaxation_bilinear-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, JuMP.VariableRef}","page":"Function References","title":"QuantumCircuitOpt.relaxation_bilinear","text":"relaxation_bilinear(m::JuMP.Model, xy::JuMP.VariableRef, x::JuMP.VariableRef, y::JuMP.VariableRef)\n\ngeneral relaxation of binlinear term (McCormick), which can be used to obtain specific variants in partiuclar cases of variables (like binary)\n\nz >= JuMP.lower_bound(x)*y + JuMP.lower_bound(y)*x - JuMP.lower_bound(x)*JuMP.lower_bound(y)\nz >= JuMP.upper_bound(x)*y + JuMP.upper_bound(y)*x - JuMP.upper_bound(x)*JuMP.upper_bound(y)\nz <= JuMP.lower_bound(x)*y + JuMP.upper_bound(y)*x - JuMP.lower_bound(x)*JuMP.upper_bound(y)\nz <= JuMP.upper_bound(x)*y + JuMP.lower_bound(y)*x - JuMP.upper_bound(x)*JuMP.lower_bound(y)\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.round_complex_values-Tuple{Matrix{ComplexF64}}","page":"Function References","title":"QuantumCircuitOpt.round_complex_values","text":"round_complex_values(M::Array{Complex{Float64},2})\n\nGiven a complex-valued matrix, this function returns a complex-valued matrix which  rounds the values closest to 0, 1 and -1. This is useful to avoid numerical issues. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.round_real_value-Tuple{T} where T<:Number","page":"Function References","title":"QuantumCircuitOpt.round_real_value","text":"round_real_value(x::T) where T <: Number\n\nGiven a real-valued number, this function returns a real-value which rounds the values closest to 0, 1 and -1. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.silence-Tuple{}","page":"Function References","title":"QuantumCircuitOpt.silence","text":"Suppresses information and warning messages output by QuantumCircuitOpt, for fine grained control use of the Memento package\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.unique_idx-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Function References","title":"QuantumCircuitOpt.unique_idx","text":"unique_idx(x::AbstractArray{T})\n\nThis function returns the indices of unique elements in a given array of scalar or vector inputs. Overall,  this function computes faster than Julia's built-in findfirst command. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.unique_matrices-Tuple{Array{Float64, 3}}","page":"Function References","title":"QuantumCircuitOpt.unique_matrices","text":"unique_matrices(M::Array{Float64, 3})\n\nThis function returns the unique set of matrices and the corresponding indices  of unique matrices from the given set of matrices.  \n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.unitary-Tuple{String, Int64}","page":"Function References","title":"QuantumCircuitOpt.unitary","text":"unitary(input::String, num_qubits::Int64; angle = nothing)\n\nGiven an input string representing the gate and number of qubits of the circuit, this function returns a full-sized  gate with respect to the input number of qubits. For example, if num_qubits = 3 and the input gate in H_3  (Hadamard on third qubit), then this function returns IGate ⨂ IGate ⨂ HGate, where IGate and HGate are single  qubit Identity and Hadamard gates, respectively. Note that angle vector is an optional input which is  necessary when the input gate is parametrized by Euler angles.\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.variable_domain-Tuple{JuMP.VariableRef}","page":"Function References","title":"QuantumCircuitOpt.variable_domain","text":"variable_domain(var::JuMP.VariableRef)\n\nComputes the valid domain of a given JuMP variable taking into account bounds and the varaible's implicit bounds (e.g. binary).\n\n\n\n\n\n","category":"method"},{"location":"function_references/#QuantumCircuitOpt.visualize_solution-Tuple{Dict{String, Any}, Dict{String, Any}}","page":"Function References","title":"QuantumCircuitOpt.visualize_solution","text":"visualize_solution(results::Dict{String, Any}, data::Dict{String, Any}; gate_sequence = false)\n\nGiven dictionaries of results and data, and assuming that the optimization model had a feasible solution,  this function aids in visualizing the optimal circuit decomposition.\n\n\n\n\n\n","category":"method"},{"location":"multi_qubit_gates/#Quantum-Circuits-Library:-Multi-qubit-gates","page":"Multi-qubit gates","title":"Quantum Circuits Library: Multi-qubit gates","text":"","category":"section"},{"location":"multi_qubit_gates/#GRGate","page":"Multi-qubit gates","title":"GRGate","text":"","category":"section"},{"location":"multi_qubit_gates/#QuantumCircuitOpt.GRGate","page":"Multi-qubit gates","title":"QuantumCircuitOpt.GRGate","text":"GRGate(num_qubits::Int64, θ::Number, ϕ::Number)\n\nA multi-qubit rotation gate with two Euler angles, theta and phi,  applied about the cos(phi)x + sin(phi)y axis and parametrized by the number of qubits.  This gate can be applied to multiple qubits simultaneously, for a given depth.  The global R gate is native to atomic systems. In the one-qubit case, this gate is  equivalent to the RGate.\n\nReference: Qiskit's circuit library\n\nCircuit Representation (in 3 qubits)\n\n     ┌──────────┐\nq_0: ┤0         ├ \n     │          │\nq_1: ┤1 GR(ϴ,φ) ├    \n     │          │\nq_2: ┤2         ├\n     └──────────┘\n\nMatrix Representation (in 3 qubits)\n\nGR(theta phi) = exp left(-i sum_i=1^3 (cos(phi)X_i + sin(phi)Y_i) theta2 right)  \n                 = R(theta phi) otimes R(theta phi) otimes R(theta phi)  \n\n\n\n\n\n","category":"function"},{"location":"quickguide/#Quick-Start-Guide","page":"Quick Start guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide/#Framework","page":"Quick Start guide","title":"Framework","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Building on the recent success of Julia, JuMP and mixed-integer programming (MIP) solvers, QuantumCircuitOpt (or QCOpt), is an open-source toolkit for optimal quantum circuit design. As illustrated in the figure below, QCOpt is written in Julia, a relatively new and fast dynamic programming language used for technical computing with support for extensible type system and meta-programming. At a high level, QCOpt provides an abstraction layer to achieve two primary goals:","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"To capture user-specified inputs, such as a desired quantum computation and the available hardware gates, and build a JuMP model of an MIP formulation, and \nTo extract, analyze and post-process the solution from the JuMP model to provide exact and approximate circuit decompositions, up to a global phase and machine precision.","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"<align=\"center\"/>\n<img width=\"550px\" class=\"display-light-only\" src=\"../assets/QCOpt_framework.png\" alt=\"../assets/QCOpt_framework.png\"/>\n<img width=\"550px\" class=\"display-dark-only\" src=\"../assets/QCOpt_framework_dark.png\" alt=\"../assets/QCOpt_framework.png\"/>","category":"page"},{"location":"quickguide/#Video-tutorials","page":"Quick Start guide","title":"Video tutorials","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"November 2022: Presentation link from the Third Quantum Computing Software Workshop, held in conjunction with the International Conference on Super Computing (SC22). This video will introduce the importance of nonlinear programming formulations for optimal quantum circuit design. More technical details can be found in this paper. \nJuly 2022: Presentation at the JuliaCon 2022 introduces the package in greater depth and how to use it's various features. ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"<align=\"center\"/>\n<a href=\"https://www.youtube.com/watch?v=OeONXwD4JJY\">\n    <img alt=\"Youtube-link\" src=\"../assets/video_img_2.png\"\n    width=500\" height=\"350\">\n</a>","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"November 2021: Presentation from the 2nd Quantum Computing Software Workshop, held in conjunction with the International Conference on Super Computing (SC21), will introduce the technicalities underlying the package, which can also be found in this paper.","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"<align=\"center\"/>\n<a href=\"https://www.youtube.com/watch?v=sf1HJW5Vmio\">\n    <img alt=\"Youtube-link\" src=\"../assets/video_img_1.png\"\n    width=500\" height=\"350\">\n</a>","category":"page"},{"location":"quickguide/#Getting-started","page":"Quick Start guide","title":"Getting started","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"To get started, install QCOpt and JuMP, a modeling language layer for optimization. QCOpt also needs a MIP solver such as Gurobi or IBM's CPLEX. If you prefer an open-source MIP solver, install HiGHS from the Julia package manager, though be warned that the run times of QCOpt can be substantially slower using any of the open-source MIP solvers. ","category":"page"},{"location":"quickguide/#User-inputs","page":"Quick Start guide","title":"User inputs","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"QCOpt takes two types of user-defined input specifications. The first type of input contains all the necessary circuit specifications. This is given by a dictionary in Julia, which is a collection of key-value pairs, where every key is of the type String, which admits values of various types. Below is the list of allowable keys for the dictionary, given in column 1, and it's respective values with descriptions, given in column 2. This input dictionary is represented as params in all the example circuit decompositions. ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Mandatory circuit specifications Description\nnum_qubits Number of qubits of the circuit (≥ 2).\nmaximum_depth Maximum allowable depth for decomposition of the circuit (≥ 2).\nelementary_gates Vector of all one and two qubit elementary gates. The menagerie of quantum gates currently supported in QCOpt can be found in gates.jl.\ntarget_gate Target unitary gate which you wish to decompose using the above-mentioned elementary_gates.\nobjective Choose one of the following: (a) minimize_depth, which minimizes the total number of one- and two-qubit gates. For this option, include Identity matrix in the above-mentioned elementary_gates, (b) minimize_cnot, which minimizes the number of CNOT gates in the decomposition, (c) minimize_T, which minimizes the number of T gates in the circuit (default: minimize_depth)\ndecomposition_type Choose one of the following: (a) exact_optimal, which finds an exact, provably optimal, decomposition if it exists, (b) exact_feasible, which finds any feasible exact decomposition, but not necessarily an optimal one if it exists, (c) optimal_global_phase, which finds an optimal (best) circuit decomposition if it exists, up to a global phase (d) approximate, which finds an approximate decomposition if an exact one does not exist; otherwise it will return an exact decomposition (default: exact_optimal)","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"If the above-specified elementary_gates contain gates with continuous angle parameters, then the following mandarotry input angle discretizations have to be specified in addition to the above inputs: ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Mandatory angle discretizations Description\nRX_discretization Vector of discretization angles (in radians) for RXGate. Input this only if this gate is part of the above-mentioned elementary_gates.\nRY_discretization Vector of discretization angles (in radians) for RYGate. Input this only if this gate is part of the above-mentioned elementary_gates.\nRZ_discretization Vector of discretization angles (in radians) for RZGate. Input this only if this gate is part of the above-mentioned elementary_gates.\nPhase_discretization Vector of discretization angles (in radians) for PhaseGate. Input this only if this gate is part of the above-mentioned elementary_gates.\nU3_θ_discretization Vector of discretization angles (in radians) for θ parameter in U3Gate. Input this only if this gate is part of the above-mentioned elementary_gates.\nU3_ϕ_discretization Vector of discretization angles (in radians) for ϕ parameter in U3Gate. Input this only if this gate is part of the above-mentioned elementary_gates.\nU3_λ_discretization Vector of discretization angles (in radians) for λ parameter in U3Gate. Input this only if this gate is part of the above-mentioned elementary_gates.\nCRX_discretization Vector of discretization angles (in radians) for CRXGate. Input this only if this gate is part of the above-mentioned elementary_gates.\nCRY_discretization Vector of discretization angles (in radians) for CRYGate. Input this only if this gate is part of the above-mentioned elementary_gates.\nCRZ_discretization Vector of discretization angles (in radians) for CRZGate. Input this only if this gate is part of the above-mentioned elementary_gates.\nCU3_θ_discretization Vector of discretization angles (in radians) for θ parameter in CU3Gate. Input this only if this gate is part of the above-mentioned elementary_gates.\nCU3_ϕ_discretization Vector of discretization angles (in radians) for ϕ parameter in CU3Gate. Input this only if this gate is part of the above-mentioned elementary_gates.\nCU3_λ_discretization Vector of discretization angles (in radians) for λ parameter in CU3Gate. Input this only if this gate is part of the above-mentioned elementary_gates.","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"In addition, here is a list of optional circuit specifications, which can be added to the above set of inputs, to accelerate the performance of the QCOpt package:","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Optional circuit specifications Description\ninitial_gate Intitial-condition gate to the decomposition (gate at 0th depth) (default: Identity).\nset_cnot_lower_bound This option sets a lower bound on the total number of CNot or CX gates which an optimal decomposition can admit.\nset_cnot_upper_bound This option sets an upper bound on the total number of CNot/CX gates which an optimal decomposition can admit. Note that both set_cnot_lower_bound and set_cnot_upper_bound can also be set to an identitcal value to fix the number of CNot/CX gates in the optimal decomposition.\ninput_circuit Input circuit representing an ensemble of elementary gates which decomposes the given target gate. This input circuit, which serves as a warm-start, can accelerate the MIP solver's search for the incumbent solution. (default: empty circuit).","category":"page"},{"location":"quickguide/#Optimization-model-inputs","page":"Quick Start guide","title":"Optimization model inputs","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"The second set of inputs for QCOpt contains all the optional specifications for the underlying optimization models. This is given by a dictionary in Julia, which is a collection of key-value pairs, where every key is of the type Symbol, which admits values of various types. Below is the list of allowable keys for this dictionary, given in column 1, and it's respective values with descriptions, given in column 2. This input dictionary is an optional one, as it's default values are already set in types.jl correspnding to an optimal performance of the QCOpt package. Further, this dictionary is an optional argument while executing functions, build_QCModel and run_QCModel only.","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Optional model inputs Description\nmodel_type The type of implemented MIP model to optimize in QCOpt (default: compact_formulation).\ncommute_gate_constraints This option activates the valid constraints to eliminate pairs of commuting gates in the elementary (native) gates set (default: true)\ninvolutory_gate_constraints This option activates the valid constraints to eliminate pairs of involutory gates in the elementary (native) gates set (default: true)\nredundant_gate_pair_constraints This option activates the valid constraints to eliminate redundant pairs of gates in the elementary (native) gates set (default: true)\nidentity_gate_symmetry_constraints This option activates the valid constraints to eliminate symmetry in the Identity gate in the decomposition (default: true)\nidempotent_gate_constraints This option activates the valid constraints to eliminate idempotent gates in the elementary (native) gates set (default: false)\nconvex_hull_gate_constraints This option activates the valid constraints to apply convex hull of complex entries in the elementary (native) gates set (default: false)\nfix_unitary_variables This option evaluates all the fixed-valued indices of unitary matrix varaibles (U_var) at every depth, and appropriately builds the optimization model (default: true)\nunitary_complex_conjugate Exploits the complex-conjugate transpose of gates at max_depth to impose valid constraints on the unitary matrix variables (U_var) at max_depth-1. (Default: 1)\nvisualize_solution This option activates the visualization of the optimal circuit decomposition (default: true)\nrelax_integrality This option transforms integer variables into continuous variables (default: false).\noptimizer_log This option enables or disables console logging for the optimizer (default: true).\nobjective_slack_penalty This option sets the penalty for minimizing the slack term in the objective, when decomposition_type is set to approximate (default: 1E3).\ntime_limit This option allows sets the maximum time limit for the optimizer in seconds (default: 10,800).","category":"page"},{"location":"quickguide/#Sample-circuit-synthesis","page":"Quick Start guide","title":"Sample circuit synthesis","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Using the above-described mandatory and optional user inputs, here is a sample circuit decomposition to minimize the total depth for implementing a 2-qubit controlled-Z gate (CZGate), with entangling CNOT gate and the one-qubit, universal rotation gate (U3Gate) with three discretized Euler angles (θ,ϕ,λ):","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"import QuantumCircuitOpt as QCOpt\nusing JuMP\nusing Gurobi\n\n# Target: CZGate\nfunction target_gate()\n    return Array{Complex{Float64},2}([1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 -1]) \nend\n\n# Circuit specifications (mandatory)\nparams = Dict{String, Any}(\n\"num_qubits\" => 2, \n\"maximum_depth\" => 4,    \n\"elementary_gates\" => [\"U3_1\", \"U3_2\", \"CNot_1_2\", \"Identity\"],\n\"target_gate\" => target_gate(),\n\"objective\" => \"minimize_depth\",\n\"decomposition_type\" => \"exact_optimal\",\n       \n\"U3_θ_discretization\" => -π:π/2:π,\n\"U3_ϕ_discretization\" => -π:π/2:π,\n\"U3_λ_discretization\" => -π:π/2:π,\n)\n\n# Optimization model inputs (optional)\nmodel_options = Dict{Symbol, Any}(:model_type => \"compact_formulation\",\n                                  :visualize_solution => true)\n\nqcm_optimizer = JuMP.optimizer_with_attributes(Gurobi.Optimizer, \"presolve\" => 1)\nQCOpt.run_QCModel(params, qcm_optimizer; options = model_options)","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"If you prefer to decompose a target gate of your choice, update the target_gate() function and the  set of elementary_gates accordingly in the above sample code. For more such circuit decompositions, with various types of elementary gates, refer to examples folder. ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"warning: Warning\nNote that QCOpt tries to find the global minima of a specified objective function (T-gate/CNOT-gate/Depth count) for a given set of input one- and two-qubit gates, target gate and the total depth of the decomposition. This combinatiorial optimization problem is known to be NP-hard to compute in the size of num_qubits, maximum_depth and elementary_gates link. ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"tip: Tip\nRun times of QCOpt's mathematical optimization models are significantly faster using Gurobi as the underlying mixed-integer programming (MIP) solver. Note that this solver's individual-usage license is available free for academic purposes. ","category":"page"},{"location":"quickguide/#Extracting-results","page":"Quick Start guide","title":"Extracting results","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"The run commands (for example, run_QCModel) in QCOpt return detailed results in the form of a dictionary. This dictionary can be saved for further processing as follows,","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"results = QCOpt.run_QCModel(params, qcm_optimizer)","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"For example, for decomposing the above controlled-Z gate, the QCOpt's runtime and the optimal objective value (minimum depth) can be accessed using,","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"results[\"solve_time\"]\nresults[\"objective\"]","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Also, results[\"solution\"] contains detailed information about the solution produced by the optimization model, which can be utilized for further analysis. ","category":"page"},{"location":"quickguide/#Visualizing-results","page":"Quick Start guide","title":"Visualizing results","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"QCOpt currently supports the visualization of optimal circuit decompositions obtained from the results dictionary (from above), which can be executed using,","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"data = QCOpt.get_data(params)\nQCOpt.visualize_solution(results, data)","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"For example, for the above controlled-Z gate decomposition, the processed QCOpt output is shown below (on Apple M4 Max with Gurobi 12.0.1): ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"=============================================================================\nQuantumCircuitOpt version: 0.6.1\n\nQuantum Circuit Model Data\n  Number of qubits: 2\n  Total number of elementary gates (after presolve): 72\n  Maximum depth of decomposition: 4\n  Elementary gates: [\"U3_1\", \"U3_2\", \"CNot_1_2\", \"Identity\"]\n    U3_θ discretization: [-180.0, -90.0, 0.0, 90.0, 180.0]\n    U3_ϕ discretization: [-180.0, -90.0, 0.0, 90.0, 180.0]\n    U3_λ discretization: [-180.0, -90.0, 0.0, 90.0, 180.0]\n  Type of decomposition: exact_optimal\n  MIP optimizer: Gurobi\n\nOptimal Circuit Decomposition\n  U3_2(-90.0,0.0,0.0) * CNot_1_2 * U3_2(90.0,0.0,0.0) = Target gate\n  Minimum optimal depth: 3\n  Optimizer run time: 1.18 sec.\n=============================================================================","category":"page"},{"location":"1_qubit_gates/#Quantum-Circuits-Library:-Single-qubit-gates","page":"1-qubit gates","title":"Quantum Circuits Library: Single-qubit gates","text":"","category":"section"},{"location":"1_qubit_gates/#IGate","page":"1-qubit gates","title":"IGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.IGate","page":"1-qubit gates","title":"QuantumCircuitOpt.IGate","text":"IGate(num_qubits::Int64)\n\nIdentity matrix for an input number of qubits.\n\nMatrix Representation (num_qubits = 1)\n\nI = beginpmatrix\n        1  0 \n        0  1\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#U3Gate","page":"1-qubit gates","title":"U3Gate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.U3Gate","page":"1-qubit gates","title":"QuantumCircuitOpt.U3Gate","text":"U3Gate(θ::Number, ϕ::Number, λ::Number)\n\nUniversal single-qubit rotation gate with three Euler angles, theta, phi and lambda.\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nU3(theta phi lambda) =\n    beginpmatrix\n        cos(th)           -e^ilambdasin(th) \n        e^iphisin(th)  e^i(phi+lambda)cos(th)\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#U2Gate","page":"1-qubit gates","title":"U2Gate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.U2Gate","page":"1-qubit gates","title":"QuantumCircuitOpt.U2Gate","text":"U2Gate(ϕ::Number, λ::Number)\n\nUniversal single-qubit rotation gate with two Euler angles, phi and lambda. U2Gate is the special case of  U3Gate. \n\nMatrix Representation\n\nU2(phi lambda) = frac1sqrt2\nbeginpmatrix\n    1           -e^ilambda \n    e^iphi  e^i(phi+lambda)\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#U1Gate","page":"1-qubit gates","title":"U1Gate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.U1Gate","page":"1-qubit gates","title":"QuantumCircuitOpt.U1Gate","text":"U1Gate(λ::Number)\n\nUniversal single-qubit rotation gate with one Euler angle, lambda. U1Gate represents rotation about the Z axis and  is the special case of U3Gate, which also known as the PhaseGate. Also note that U1(pi) =ZGate, U1(pi2) =SGate and  U1(pi4) =TGate.\n\nMatrix Representation\n\nU1(lambda) =\nbeginpmatrix\n    1  0 \n    0  e^ilambda\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#RGate","page":"1-qubit gates","title":"RGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.RGate","page":"1-qubit gates","title":"QuantumCircuitOpt.RGate","text":"RGate(θ::Number, ϕ::Number)\n\nA single-qubit rotation gate with two Euler angles, theta and phi,  about the cos(phi)x + sin(phi)y axis. \n\nMatrix Representation\n\nR(theta phi) =  e^-i theta left(cosphi x + sinphi yright) =\nbeginpmatrix\n    costheta  -i e^-i phi sintheta \n    -i e^i phi sintheta  costheta\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#RXGate","page":"1-qubit gates","title":"RXGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.RXGate","page":"1-qubit gates","title":"QuantumCircuitOpt.RXGate","text":"RXGate(θ::Number)\n\nA single-qubit Pauli gate which represents rotation about the X axis.\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nRX(theta) = exp(-i th X) =\n    beginpmatrix\n        costh    -isinth \n        -isinth  costh\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#RYGate","page":"1-qubit gates","title":"RYGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.RYGate","page":"1-qubit gates","title":"QuantumCircuitOpt.RYGate","text":"RYGate(θ::Number)\n\nA single-qubit Pauli gate which represents rotation about the Y axis.\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nRY(theta) = exp(-i th Y) =\n    beginpmatrix\n        costh  -sinth \n        sinth  costh\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#RZGate","page":"1-qubit gates","title":"RZGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.RZGate","page":"1-qubit gates","title":"QuantumCircuitOpt.RZGate","text":"RZGate(θ::Number)\n\nA single-qubit Pauli gate which represents rotation about the Z axis. This gate is also equivalent to U1Gate up to a phase factor,  that is, RZ(theta) = e^-itheta2U1(theta).\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nRZ(theta) = exp(-ith Z) =\nbeginpmatrix\n    e^-ith  0 \n    0  e^ith\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#HGate","page":"1-qubit gates","title":"HGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.HGate","page":"1-qubit gates","title":"QuantumCircuitOpt.HGate","text":"HGate()\n\nSingle-qubit Hadamard gate, which is a pi rotation about the X+Z axis, thus equivalent to U3Gate(fracpi20pi)\n\nMatrix Representation\n\nH = frac1sqrt2\n        beginpmatrix\n            1  1 \n            1  -1\n        endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#XGate","page":"1-qubit gates","title":"XGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.XGate","page":"1-qubit gates","title":"QuantumCircuitOpt.XGate","text":"XGate()\n\nSingle-qubit Pauli-X gate (sigma_x), equivalent to U3Gate(pi0pi)\n\nMatrix Representation\n\nX = beginpmatrix\n0  1 \n1  0\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#YGate","page":"1-qubit gates","title":"YGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.YGate","page":"1-qubit gates","title":"QuantumCircuitOpt.YGate","text":"YGate()\n\nSingle-qubit Pauli-Y gate (sigma_y), equivalent to U3Gate(pifracpi2fracpi2)\n\nMatrix Representation\n\nY = beginpmatrix\n0  -i \ni  0\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#ZGate","page":"1-qubit gates","title":"ZGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.ZGate","page":"1-qubit gates","title":"QuantumCircuitOpt.ZGate","text":"ZGate()\n\nSingle-qubit Pauli-Z gate (sigma_z), equivalent to U3Gate(00pi)\n\nMatrix Representation\n\nZ = beginpmatrix\n1  0 \n0  -1\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#SGate","page":"1-qubit gates","title":"SGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.SGate","page":"1-qubit gates","title":"QuantumCircuitOpt.SGate","text":"SGate()\n\nSingle-qubit S gate, equivalent to U3Gate(00fracpi2). This  gate is also referred to as a Clifford gate, P gate or a square-root of Pauli-ZGate. Historically, this is also  called as the phase gate (denoted by P), since it shifts the phase of the one state relative to the zero state.\n\nMatrix Representation\n\nS = beginpmatrix\n1  0 \n0  i\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#SdaggerGate","page":"1-qubit gates","title":"SdaggerGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.SdaggerGate","page":"1-qubit gates","title":"QuantumCircuitOpt.SdaggerGate","text":"SdaggerGate()\n\nSingle-qubit, hermitian conjugate of the SGate. This is also an alternative square root of  the ZGate. \n\nMatrix Representation\n\nS = beginpmatrix\n1  0 \n0  -i\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#TGate","page":"1-qubit gates","title":"TGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.TGate","page":"1-qubit gates","title":"QuantumCircuitOpt.TGate","text":"TGate()\n\nSingle-qubit T gate, equivalent to U3Gate(00fracpi4). This  gate is also referred to as a fracpi8 gate or as a fourth-root of Pauli-ZGate. \n\nMatrix Representation\n\nT = beginpmatrix\n1  0 \n0  e^ipi4\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#TdaggerGate","page":"1-qubit gates","title":"TdaggerGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.TdaggerGate","page":"1-qubit gates","title":"QuantumCircuitOpt.TdaggerGate","text":"TdaggerGate()\n\nSingle-qubit, hermitian conjugate of the TGate. This gate is equivalent to U3Gate(00-fracpi4). This  gate is also referred to as the fourth-root of Pauli-ZGate. \n\nMatrix Representation\n\nT^dagger = beginpmatrix\n1  0 \n0  e^-ipi4\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#SXGate","page":"1-qubit gates","title":"SXGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.SXGate","page":"1-qubit gates","title":"QuantumCircuitOpt.SXGate","text":"SXGate()\n\nSingle-qubit square root of pauli-XGate.\n\nMatrix Representation\n\nsqrtX = frac12 beginpmatrix\n1 + i  1 - i \n1 - i  1 + i\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#SXdaggerGate","page":"1-qubit gates","title":"SXdaggerGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.SXdaggerGate","page":"1-qubit gates","title":"QuantumCircuitOpt.SXdaggerGate","text":"SXdaggerGate()\n\nSingle-qubit hermitian conjugate of the square root of pauli-XGate, or the SXGate.\n\nMatrix Representation\n\nsqrtX^dagger = frac12 beginpmatrix\n1 - i  1 + i \n1 + i  1 - i\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"1_qubit_gates/#PhaseGate","page":"1-qubit gates","title":"PhaseGate","text":"","category":"section"},{"location":"1_qubit_gates/#QuantumCircuitOpt.PhaseGate","page":"1-qubit gates","title":"QuantumCircuitOpt.PhaseGate","text":"PhaseGate(λ::Number)\n\nSingle-qubit rotation gate about the Z axis. This is also equivalent to U3Gate(00lambda). This  gate is also referred to as the U1Gate. \n\nMatrix Representation\n\nP(lambda) = beginpmatrix\n    1  0 \n    0  e^ilambda\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#Quantum-Circuits-Library:-Two-qubit-gates","page":"2-qubit gates","title":"Quantum Circuits Library: Two-qubit gates","text":"","category":"section"},{"location":"2_qubit_gates/#CNotGate","page":"2-qubit gates","title":"CNotGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CNotGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CNotGate","text":"CNotGate()\n\nTwo-qubit controlled NOT gate with control and target on first and second qubits, respectively. This is also  called the controlled X gate (CXGate). \n\nCircuit Representation\n\nq_0: ──■──\n     ┌─┴─┐\nq_1: ┤ X ├\n     └───┘\n\nMatrix Representation\n\nCNot = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CNotRevGate","page":"2-qubit gates","title":"CNotRevGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CNotRevGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CNotRevGate","text":"CNotRevGate()\n\nTwo-qubit reverse controlled NOT gate, with target and control on first and second qubits, respectively. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ X ├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCNotRev = beginpmatrix\n            1  0  0  0 \n            0  0  0  1 \n            0  0  1  0 \n            0  1  0  0\n            endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#DCXGate","page":"2-qubit gates","title":"DCXGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.DCXGate","page":"2-qubit gates","title":"QuantumCircuitOpt.DCXGate","text":"DCXGate()\n\nTwo-qubit double controlled NOT gate consisting of two back-to-back CNotGates with alternate controls. \n\nCircuit Representation\n\n          ┌───┐\nq_0: ──■──┤ X ├\n     ┌─┴─┐└─┬─┘\nq_1: ┤ X ├──■──\n     └───┘\n\nMatrix Representation\n\nDCX = beginpmatrix\n    1  0  0  0 \n    0  0  0  1 \n    0  1  0  0 \n    0  0  1  0\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CXGate","page":"2-qubit gates","title":"CXGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CXGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CXGate","text":"CXGate()\n\nTwo-qubit controlled XGate, which is also the same as CNotGate. \n\nCircuit Representation\n\nq_0: ──■──\n     ┌─┴─┐\nq_1: ┤ X ├\n     └───┘\n\nMatrix Representation\n\nCX = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CXRevGate","page":"2-qubit gates","title":"CXRevGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CXRevGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CXRevGate","text":"CXRevGate()\n\nTwo-qubit reverse controlled-X gate, with target and control on first and second qubits, respectively.  This is also the same as CNotRevGate. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ X ├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCXRev = I otimes 0 ranglelangle 0 + X otimes 1 ranglelangle 1 = beginpmatrix\n        1  0  0  0 \n        0  0  0  1 \n        0  0  1  0 \n        0  1  0  0\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CYGate","page":"2-qubit gates","title":"CYGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CYGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CYGate","text":"CYGate()\n\nTwo-qubit controlled YGate. \n\nCircuit Representation\n\nq_0: ──■──\n     ┌─┴─┐\nq_1: ┤ Y ├\n     └───┘\n\nMatrix Representation\n\nCY = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes Y = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  -i \n    0  0  i  0\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CYRevGate","page":"2-qubit gates","title":"CYRevGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CYRevGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CYRevGate","text":"CYRevGate()\n\nTwo-qubit reverse controlled-Y gate, with target and control on first and second qubits, respectively. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ Y ├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCYRev = I otimes 0 ranglelangle 0 + Y otimes 1 ranglelangle 1 = beginpmatrix\n        1  0  0  0 \n        0  0  0  -i \n        0  0  1  0 \n        0  i  0  0\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CZGate","page":"2-qubit gates","title":"CZGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CZGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CZGate","text":"CZGate()\n\nTwo-qubit, symmetric, controlled ZGate. \n\nCircuit Representation\n\nq_0: ──■──     ─■─\n     ┌─┴─┐  ≡   │\nq_1: ┤ Z ├     ─■─\n     └───┘\n\nMatrix Representation\n\nCZ = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes Z = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CHGate","page":"2-qubit gates","title":"CHGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CHGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CHGate","text":"CHGate()\n\nTwo-qubit, symmetric, controlled Hadamard gate (HGate). \n\nCircuit Representation\n\nq_0: ──■──\n     ┌─┴─┐  \nq_1: ┤ H ├    \n     └───┘\n\nMatrix Representation\n\nCH = 0ranglelangle 0 otimes I + 1ranglelangle 1 otimes H = beginpmatrix\n1  0  0  0 \n0  1  0  0 \n0  0  frac1sqrt2  frac1sqrt2 \n0  0  frac1sqrt2  -frac1sqrt2\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CHRevGate","page":"2-qubit gates","title":"CHRevGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CHRevGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CHRevGate","text":"CHRevGate()\n\nTwo-qubit reverse controlled-H gate, with target and control on first and second qubits, respectively. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ H ├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCHRev = I otimes 0ranglelangle 0 + H otimes 1ranglelangle 1 = beginpmatrix\n        1  0  0  0 \n        0  frac1sqrt2  0  frac1sqrt2 \n        0  0  1  0 \n        0  frac1sqrt2  0  -frac1sqrt2\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CVGate","page":"2-qubit gates","title":"CVGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CVGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CVGate","text":"CVGate()\n\nTwo-qubit, controlled-V gate, which is also the same as Controlled square-root of X gate (CSXGate).  \n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ V ├     \n     └───┘\n\nMatrix Representation\n\nCV = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  05+05i  05-05i \n        0  0  05-05i  05+05i\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CVRevGate","page":"2-qubit gates","title":"CVRevGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CVRevGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CVRevGate","text":"CVRevGate()\n\nTwo-qubit reverse controlled-V gate, with target and control on first and second qubits, respectively. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ V ├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCVRev = beginpmatrix\n        1  0  0  0 \n        0  05+05i  0  05-05i \n        0  0  1  0 \n        0  05-05i  0  05+05i\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CVdaggerGate","page":"2-qubit gates","title":"CVdaggerGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CVdaggerGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CVdaggerGate","text":"CVdaggerGate()\n\nTwo-qubit hermitian conjugate of controlled-V gate, which is also the same as hermitian conjugate Controlled square-root of X gate (CSXGate).  \n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ V'├     \n     └───┘\n\nMatrix Representation\n\nCVdagger = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  05-05i  05+05i \n        0  0  05+05i  05-05i\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CVdaggerRevGate","page":"2-qubit gates","title":"CVdaggerRevGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CVdaggerRevGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CVdaggerRevGate","text":"CVdaggerRevGate()\n\nTwo-qubit hermitian conjugate of reverse controlled-V gate, with target and control on first and second qubits, respectively. \n\nCircuit Representation\n\n     ┌───┐\nq_0: ┤ V'├\n     └─┬─┘\nq_1: ──■──\n\nMatrix Representation\n\nCVdaggerRev = beginpmatrix\n        1  0  0  0 \n        0  05-05i  0  05+05i \n        0  0  1  0 \n        0  05+05i  0  05-05i\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#WGate","page":"2-qubit gates","title":"WGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.WGate","page":"2-qubit gates","title":"QuantumCircuitOpt.WGate","text":"WGate()\n\nTwo-qubit, W hermitian gate, typically useful to diagonlize the (SwapGate).  \n\nMatrix Representation\n\nW = beginpmatrix\n        1  0  0  0 \n        0  frac1sqrt2  frac1sqrt2  0 \n        0  frac1sqrt2  -frac1sqrt2  0 \n        0  0  0  1\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CRXGate","page":"2-qubit gates","title":"CRXGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CRXGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CRXGate","text":"CRXGate(θ::Number)\n\nTwo-qubit controlled RXGate. \n\nCircuit Representation\n\nq_0: ────■────\n     ┌───┴───┐\nq_1: ┤ RX(ϴ) ├\n     └───────┘\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRX(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RX(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  costh    -isinth \n        0  0  -isinth  costh\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CRXRevGate","page":"2-qubit gates","title":"CRXRevGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CRXRevGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CRXRevGate","text":"CRXRevGate(θ::Number)\n\nTwo-qubit controlled reverse RXGate. \n\nCircuit Representation\n\n     ┌───────┐\nq_1: ┤ RX(ϴ) ├\n     └───┬───┘\nq_0: ────■────\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRXRev(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RX(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  costh  0  -isinth \n        0  0  1  0\n        0  -isinth  0  costh\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CRYGate","page":"2-qubit gates","title":"CRYGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CRYGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CRYGate","text":"CRYGate(θ::Number)\n\nTwo-qubit controlled RYGate. \n\nCircuit Representation\n\nq_0: ────■────\n     ┌───┴───┐\nq_1: ┤ RY(ϴ) ├\n     └───────┘\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRY(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RY(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  costh    -sinth \n        0  0  sinth  costh\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CRYRevGate","page":"2-qubit gates","title":"CRYRevGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CRYRevGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CRYRevGate","text":"CRYRevGate(θ::Number)\n\nTwo-qubit controlled reverse RYGate. \n\nCircuit Representation\n\n     ┌───────┐\nq_1: ┤ RY(ϴ) ├\n     └───┬───┘\nq_0: ────■────\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRYRev(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RY(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  costh  0  -sinth \n        0  0  1  0 \n        0  sinth  0  costh\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CRZGate","page":"2-qubit gates","title":"CRZGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CRZGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CRZGate","text":"CRZGate(θ::Number)\n\nTwo-qubit controlled RZGate. \n\nCircuit Representation\n\nq_0: ────■────\n     ┌───┴───┐\nq_1: ┤ RZ(ϴ) ├\n     └───────┘\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRZ(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RZ(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  e^-ith    0 \n        0  0  0  e^ith\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CRZRevGate","page":"2-qubit gates","title":"CRZRevGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CRZRevGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CRZRevGate","text":"CRZRevGate(θ::Number)\n\nTwo-qubit controlled reverse RZGate. \n\nCircuit Representation\n\n     ┌───────┐\nq_1: ┤ RZ(ϴ) ├\n     └───┬───┘\nq_0: ────■────\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCRZRev(theta) q_1 q_0 =\n0ranglelangle0 otimes I + 1ranglelangle1 otimes RZ(theta) =\n    beginpmatrix\n        1  0  0  0 \n        0  e^-ith  0  0 \n        0  0  1   0 \n        0  0  0  e^ith\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CSGate","page":"2-qubit gates","title":"CSGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CSGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CSGate","text":"CSGate()\n\nTwo-qubit, controlled-S gate, which induces π/2 phase in the target qubit.  This gate is invariant to the swap of control and target qubits.\n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ S ├     \n     └───┘\n\nMatrix Representation\n\nCS = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes S = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  1  0 \n        0  0  0  i\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CSdaggerGate","page":"2-qubit gates","title":"CSdaggerGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CSdaggerGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CSdaggerGate","text":"CSdaggerGate()\n\nTwo-qubit hermitian conjugate of controlled-S gate. This gate is invariant to the swap of control and target qubits.\n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ S'├     \n     └───┘\n\nMatrix Representation\n\nCSdagger = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes S^dagger = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  1  0 \n        0  0  0  -i\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CTGate","page":"2-qubit gates","title":"CTGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CTGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CTGate","text":"CTGate()\n\nTwo-qubit, controlled-T gate, which induces a π/4 phase in the target qubit.  This gate is invariant to the swap of control and target qubits.\n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ T ├     \n     └───┘\n\nMatrix Representation\n\nCT = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes T = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  1  0 \n        0  0  0  e^ipi4\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CTdaggerGate","page":"2-qubit gates","title":"CTdaggerGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CTdaggerGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CTdaggerGate","text":"CTdaggerGate()\n\nTwo-qubit hermitian conjugate of controlled-T gate. This gate is invariant to the swap of control and target qubits.\n\nCircuit Representation\n\nq_0: ──■──     \n     ┌─┴─┐    \nq_1: ┤ T'├     \n     └───┘\n\nMatrix Representation\n\nCTdagger = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes T^dagger = beginpmatrix\n        1  0  0  0 \n        0  1  0  0 \n        0  0  1  0 \n        0  0  0  e^-ipi4\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CU3Gate","page":"2-qubit gates","title":"CU3Gate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CU3Gate","page":"2-qubit gates","title":"QuantumCircuitOpt.CU3Gate","text":"CU3Gate(θ::Number, ϕ::Number, λ::Number)\n\nTwo-qubit, controlled version of the universal rotation gate with three Euler angles (U3Gate). \n\nCircuit Representation\n\nq_0: ──────■──────\n     ┌─────┴─────┐\nq_1: ┤ U3(ϴ,φ,λ) ├\n     └───────────┘\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCU3(theta phi lambda) q_1 q_0 =\n                0ranglelangle 0 otimes I +\n                1ranglelangle 1 otimes U3(thetaphilambda) =\n                beginpmatrix\n                    1  0    0                   0 \n                    0  1    0                   0 \n                    0  0    cos(th)           -e^ilambdasin(th) \n                    0  0    e^iphisin(th)  e^i(phi+lambda)cos(th)\n                endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CU3RevGate","page":"2-qubit gates","title":"CU3RevGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CU3RevGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CU3RevGate","text":"CU3RevGate(θ::Number, ϕ::Number, λ::Number)\n\nTwo-qubit, reverse controlled version of the universal rotation gate with three Euler angles (U3Gate). \n\nCircuit Representation\n\n     ┌────────────┐\nq_1: ┤  U3(ϴ,φ,λ) ├\n     └──────┬─────┘\nq_0: ───────■──────\n\nMatrix Representation\n\nnewcommandthfractheta2\n\nCU3(theta phi lambda) q_1 q_0 =\n                0ranglelangle 0 otimes I +\n                1ranglelangle 1 otimes U3(thetaphilambda) =\n                beginpmatrix\n                    1  0    0   0 \n                    0  cos(th)    0  -e^ilambdasin(th) \n                    0  0     1  0 \n                    0  e^iphisin(th)   0   e^i(phi+lambda)cos(th)\n                endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#SwapGate","page":"2-qubit gates","title":"SwapGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.SwapGate","page":"2-qubit gates","title":"QuantumCircuitOpt.SwapGate","text":"SwapGate()\n\nTwo-qubit, symmetric, SWAP gate. \n\nCircuit Representation\n\nq_0: ─X─\n      │\nq_1: ─X─\n\nMatrix Representation\n\nSWAP = beginpmatrix\n1  0  0  0 \n0  0  1  0 \n0  1  0  0 \n0  0  0  1\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#fSwapGate","page":"2-qubit gates","title":"fSwapGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.fSwapGate","page":"2-qubit gates","title":"QuantumCircuitOpt.fSwapGate","text":"fSwapGate()\n\nTwo-qubit, symmetric, Fermionic SWAP gate, that swaps adjacent fermionic modes  in the Jordan-Wigner representation. Because the qubits represent identical  fermions, swapping two particles applies a -1 phase to the state.\n\nReference: https://doi.org/10.22331/q-2018-12-21-114\n\nMatrix Representation\n\nfSWAP = beginpmatrix\n1  0  0  0 \n0  0  1  0 \n0  1  0  0 \n0  0  0  -1\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#SSwapGate","page":"2-qubit gates","title":"SSwapGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.SSwapGate","page":"2-qubit gates","title":"QuantumCircuitOpt.SSwapGate","text":"SSwapGate()\n\nTwo-qubit, square root version of the SwapGate. \n\nCircuit Representation\n\n     ┌────────────┐\nq_0: ┤            ├\n     │ sqrt(Swap) │   \nq_1: ┤            ├ \n     └────────────┘ \n\nMatrix Representation\n\nSWAP = beginpmatrix\n1  0  0  0 \n0  05+05i  05-05i  0 \n0  05-05i  05+05i  0 \n0  0  0  1\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#iSwapGate","page":"2-qubit gates","title":"iSwapGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.iSwapGate","page":"2-qubit gates","title":"QuantumCircuitOpt.iSwapGate","text":"iSwapGate()\n\nTwo-qubit, symmetric and clifford, iSWAP gate. This is an entangling swapping gate where the qubits  obtain a phase of i if the state of the qubits is swapped.\n\nCircuit Representation\n\nq_0: ─⨂─\n      │     \nq_1: ─⨂─    \n\nMinimum depth representation\n\n      ┌───┐     ┌───┐ ┌───┐\nq_0: ─┤ X ├──■──┤ S ├─┤ X ├─\n      └─┬─┘┌─┴─┐└───┘ └─┬─┘\nq_1: ───■──┤ X ├────────■──\n           └───┘\n\nMatrix Representation\n\niSWAP = beginpmatrix\n1  0  0  0 \n0  0  i  0 \n0  i  0  0 \n0  0  0  1\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CSXGate","page":"2-qubit gates","title":"CSXGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CSXGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CSXGate","text":"CSXGate()\n\nTwo-qubit controlled version of (SXGate). \n\nCircuit Representation\n\nq_0: ─────■─────\n     ┌────┴────┐\nq_1: ┤ sqrt(X) ├\n     └─────────┘\n\nMatrix Representation\n\nCSXGate = 0 ranglelangle 0 otimes I + 1 ranglelangle 1 otimes SX = beginpmatrix\n1  0  0  0 \n0  1  0  0 \n0  0  05+05i  05-05i \n0  0  05-05i  05+05i\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#CSXRevGate","page":"2-qubit gates","title":"CSXRevGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.CSXRevGate","page":"2-qubit gates","title":"QuantumCircuitOpt.CSXRevGate","text":"CSXRevGate()\n\nTwo-qubit controlled version of the reverse (SXGate). \n\nCircuit Representation\n\n     ┌─────────┐\nq_1: ┤ sqrt(X) ├\n     └────┬────┘\nq_0: ─────■────\n\nMatrix Representation\n\nCSXRevGate = I otimes 0ranglelangle 0 + SX otimes 1ranglelangle 1 = beginpmatrix\n1  0  0  0 \n0  05+05i  0  05-05i \n0  0  1  0 \n0  05-05i  0  05+05i\n    endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#MGate","page":"2-qubit gates","title":"MGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.MGate","page":"2-qubit gates","title":"QuantumCircuitOpt.MGate","text":"MGate()\n\nTwo-qubit Magic gate, also known as the Ising coupling or the XX gate.\n\nReference: https://doi.org/10.1103/PhysRevA.69.032315\n\nCircuit Representation\n\n      ┌───┐        ┌───┐\nq_0: ─┤ X ├────────┤ S ├\n      └─┬─┘        └─┬─┘        \n        │   ┌───┐  ┌─┴─┐\nq_1: ───■───┤ H ├──┤ S ├\n            └───┘  └───┘\n\nMatrix Representation\n\nM = frac1sqrt2 beginpmatrix\n1  i  0  0 \n0  0  i  1 \n0  0  i  -1 \n1  -i  0  0\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#QFT2Gate","page":"2-qubit gates","title":"QFT2Gate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.QFT2Gate","page":"2-qubit gates","title":"QuantumCircuitOpt.QFT2Gate","text":"QFT2Gate()\n\nTwo-qubit Quantum Fourier Transform (QFT) gate, where the QFT operation on n-qubits is given by: \n\njrangle mapsto frac12^n2 sum_k=0^2^n - 1 e^2pi ijk  2^n krangle\n\nCircuit Representation\n\n     ┌──────┐\nq_0: ┤      ├\n     │ QFT2 │   \nq_1: ┤      ├ \n     └──────┘ \n\nMatrix Representation\n\nM = frac12 beginpmatrix\n1  1  1  1 \n1  i  -1  -i \n1  -1  1  -1 \n1  -i  -1  i\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#HCoinGate","page":"2-qubit gates","title":"HCoinGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.HCoinGate","page":"2-qubit gates","title":"QuantumCircuitOpt.HCoinGate","text":"HCoinGate()\n\nTwo-qubit, Hadamard Coin gate when implemented in tune with the quantum cellular automata.  Reference: https://doi.org/10.1007/s11128-018-1983-x, https://arxiv.org/pdf/2106.03115.pdf\n\nMatrix Representation\n\nHCoinGate = beginpmatrix\n1  0  0  0 \n0  frac1sqrt2  frac1sqrt2  0 \n0  frac1sqrt2  -frac1sqrt2  0 \n0  0  0  1\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#GroverDiffusionGate","page":"2-qubit gates","title":"GroverDiffusionGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.GroverDiffusionGate","page":"2-qubit gates","title":"QuantumCircuitOpt.GroverDiffusionGate","text":"GroverDiffusionGate()\n\nTwo-qubit, Grover's diffusion operator, a key building block of the Glover's algorithm used to find a specific item (with probability > 0.5) within a randomly ordered database of N items in O(sqrt(N)) operations.  Reference: https://arxiv.org/pdf/1804.03719.pdf\n\nMatrix Representation\n\nGroverDiffusionGate = frac12beginpmatrix\n1  -1  -1  -1 \n-1  1  -1  -1 \n-1  -1  1  -1  \n-1  -1  -1  1\nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"2_qubit_gates/#SycamoreGate","page":"2-qubit gates","title":"SycamoreGate","text":"","category":"section"},{"location":"2_qubit_gates/#QuantumCircuitOpt.SycamoreGate","page":"2-qubit gates","title":"QuantumCircuitOpt.SycamoreGate","text":"SycamoreGate()\n\nTwo-qubit Sycamore Gate, native to Google's universal quantum processor. Reference: quantumai.google/cirq/google/devices\n\nCircuit Representation\n\n     ┌──────┐\nq_0: ┤      ├\n     │ SYC  │   \nq_1: ┤      ├ \n     └──────┘ \n\nMatrix Representation\n\n\nSycamoreGate() = beginpmatrix\n1  0  0  0 \n0  0  -i  0 \n0  -i  0  0  \n0  0  0  e^-i fracpi6\nendpmatrix\n\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"<align=\"center\"/>\n<img width=\"790px\" class=\"display-light-only\" src=\"assets/docs_header.png\" alt=\"assets/docs_header.png\"/>\n<img width=\"790px\" class=\"display-dark-only\" src=\"assets/docs_header_dark.png\" alt=\"assets/docs_header.png\"/>","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumCircuitOpt is a Julia package which implements discrete optimization-based methods for provably optimal synthesis of an architecture for Quantum circuits. While programming Quantum Computers, a primary goal is to build useful and less-noisy quantum circuits from the basic building blocks, also termed as elementary gates which arise due to hardware constraints. Thus, given a desired quantum computation, as a target gate, and a set of elemental one- and two-qubit gates, this package provides a provably optimal, exact (up to global phase and machine precision) or an approximate decomposition with minimum number of elemental gates and CNOT gates. Now, this package also supports multi-qubit gates in the elementary gates set, such as the global rotation gate which is native to trapped ion quantum computers. Note that QuantumCircuitOpt currently supports only decompositions of circuits up to ten qubits.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Overall, QuantumCircuitOpt can be a useful tool for researchers and developers working on quantum algorithms or quantum computing applications, as it can help to reduce the resource requirements of quantum computations, making them more practical and efficient.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To use QuantumCircuitOpt, first download and install Julia. Note that the current version of QuantumCircuitOpt is compatible with Julia 1.0 and later. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The latest stable release of QuantumCircuitOpt can be installed by entering the following in the Julia REPL-mode:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"QuantumCircuitOpt\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"At least one mixed-integer programming (MIP) solver is required for running QuantumCircuitOpt. The well-known Gurobi or IBM's CPLEX solver is highly recommended, as it is fast, scaleable and can be used to solve on fairly large-scale circuits. However, the open-source MIP solver HiGHS is also compatible with QuantumCircuitOpt. Gurobi (or any other MIP solver) can be installed via the package manager with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"Gurobi\")","category":"page"},{"location":"#Unit-Tests","page":"Introduction","title":"Unit Tests","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To run the tests in the package, run the following command after installing the QuantumCircuitOpt package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.test(\"QuantumCircuitOpt\")","category":"page"},{"location":"#Acknowledgement","page":"Introduction","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This work was supported by Los Alamos National Laboratory's LDRD Early Career Research award. The primary developer of this package is Harsha Nagarajan (@harshangrjn). ","category":"page"},{"location":"#Citing-QuantumCircuitOpt","page":"Introduction","title":"Citing QuantumCircuitOpt","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you find QuantumCircuitOpt useful in your work, we request you to cite the following publication (IEEE link, arXiv link):  ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@inproceedings{NagarajanLockwoodCoffrin2021,\n  title={{QuantumCircuitOpt}: An Open-source Framework for Provably Optimal Quantum Circuit Design},\n  author={Nagarajan, Harsha and Lockwood, Owen and Coffrin, Carleton},\n  booktitle={SC21: The International Conference for High Performance Computing, Networking, Storage, and Analysis},\n  series={Second Workshop on Quantum Computing Software},\n  pages={55--63},\n  year={2021},\n  doi={10.1109/QCS54837.2021.00010},\n  organization={IEEE Computer Society}\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Another publication which explores the potential of non-linear programming formulations in the QuantumCircuitOpt package is the following (IEEE link, arXiv link): ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@inproceedings{HendersonNagarajanCoffrin2022,\n  title={Exploring Non-linear Programming Formulations in {QuantumCircuitOpt} for Optimal Circuit Design},\n  author={Henderson. R, Elena and Nagarajan, Harsha and Coffrin, Carleton},\n  booktitle={SC22: The International Conference for High Performance Computing, Networking, Storage, and Analysis},\n  series={Third Workshop on Quantum Computing Software},\n  pages={36--42},\n  year={2022},\n  doi={10.1109/QCS56647.2022.00009},\n  organization={IEEE Computer Society}\n}","category":"page"},{"location":"3_qubit_gates/#Quantum-Circuits-Library:-Three-qubit-gates","page":"3-qubit gates","title":"Quantum Circuits Library: Three-qubit gates","text":"","category":"section"},{"location":"3_qubit_gates/#ToffoliGate","page":"3-qubit gates","title":"ToffoliGate","text":"","category":"section"},{"location":"3_qubit_gates/#QuantumCircuitOpt.ToffoliGate","page":"3-qubit gates","title":"QuantumCircuitOpt.ToffoliGate","text":"ToffoliGate()\n\nThree-qubit Toffoli gate, also known as the CCX (controlled-controlled-NOT) gate. \n\nCircuit Representation\n\nq_0: ──■──\n       │\nq_1: ──■──\n     ┌─┴─┐\nq_2: ┤ X ├\n     └───┘\n\nMatrix Representation\n\nToffoli     =\n            0 rangle langle 0 otimes I otimes I + 1 rangle langle 1 otimes CXGate =\n            beginpmatrix\n                1  0  0  0  0  0  0  0\n                0  1  0  0  0  0  0  0\n                0  0  1  0  0  0  0  0\n                0  0  0  1  0  0  0  0\n                0  0  0  0  1  0  0  0\n                0  0  0  0  0  1  0  0\n                0  0  0  0  0  0  0  1\n                0  0  0  0  0  0  1  0\n            endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"3_qubit_gates/#QFT3Gate","page":"3-qubit gates","title":"QFT3Gate","text":"","category":"section"},{"location":"3_qubit_gates/#QuantumCircuitOpt.QFT3Gate","page":"3-qubit gates","title":"QuantumCircuitOpt.QFT3Gate","text":"QFT3Gate()\n\nThree-qubit Quantum Fourier Transform (QFT) gate, where the QFT operation on n-qubits is given by: \n\njrangle mapsto frac12^n2 sum_k=0^2^n - 1 e^2pi ijk  2^n krangle\n\nCircuit Representation\n\n     ┌──────┐\nq_0: ┤      ├\n     │      │   \nq_1: ┤ QFT3 ├ \n     │      │   \nq_3: ┤      ├ \n     └──────┘ \n\nMatrix Representation\n\nM = frac12sqrt2 beginpmatrix\n1   1        1        1        1   1        1        1  \n1       frac1sqrt2 + fracisqrt2            i      -frac1sqrt2 + fracisqrt2      -1      -frac1sqrt2 - fracisqrt2            -i       frac1sqrt2 - fracisqrt2  \n1        i  -1             -i   1        i  -1             -i  \n1      -frac1sqrt2 + fracisqrt2            -i       frac1sqrt2 + fracisqrt2      -1       frac1sqrt2 - fracisqrt2            i      -frac1sqrt2 - fracisqrt2  \n1  -1        1       -1        1  -1        1       -1  \n1      -frac1sqrt2 - fracisqrt2            i       frac1sqrt2 - fracisqrt2      -1       frac1sqrt2 + fracisqrt2            -i      -frac1sqrt2 + fracisqrt2  \n1        -i  -1             i   1        -i  -1             i  \n1       frac1sqrt2 - fracisqrt2            -i      -frac1sqrt2 - fracisqrt2      -1      -frac1sqrt2 + fracisqrt2            i       frac1sqrt2 + fracisqrt2  \nendpmatrix\n\n\n\n\n\n","category":"function"},{"location":"3_qubit_gates/#CSwapGate","page":"3-qubit gates","title":"CSwapGate","text":"","category":"section"},{"location":"3_qubit_gates/#QuantumCircuitOpt.CSwapGate","page":"3-qubit gates","title":"QuantumCircuitOpt.CSwapGate","text":"CSwapGate()\n\nThree-qubit, controlled SwapGate, also known as the Fredkin gate.\n\nCircuit Representation\n\nq_0: ─■─\n      │\nq_1: ─X─\n      │\nq_2: ─X─\n\nMatrix Representation\n\nCSwapGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  1  0  0  0 \n            0  0  0  0  0  0  1  0 \n            0  0  0  0  0  1  0  0 \n            0  0  0  0  0  0  0  1 \n        endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"3_qubit_gates/#CCZGate","page":"3-qubit gates","title":"CCZGate","text":"","category":"section"},{"location":"3_qubit_gates/#QuantumCircuitOpt.CCZGate","page":"3-qubit gates","title":"QuantumCircuitOpt.CCZGate","text":"CCZGate()\n\nThree-qubit controlled-controlled Z gate. \n\nCircuit Representation\n\nq_0: ─■─\n      │\nq_1: ─■─\n      │\nq_2: ─■─\n\nMatrix Representation\n\nCCZGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  1  0  0  0 \n            0  0  0  0  0  1  0  0 \n            0  0  0  0  0  0  1  0 \n            0  0  0  0  0  0  0  -1 \n        endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"3_qubit_gates/#PeresGate","page":"3-qubit gates","title":"PeresGate","text":"","category":"section"},{"location":"3_qubit_gates/#QuantumCircuitOpt.PeresGate","page":"3-qubit gates","title":"QuantumCircuitOpt.PeresGate","text":"PeresGate()\n\nThree-qubit Peres gate. This gate is equivalent to ToffoliGate followed by the CNotGate in 3 qubits.  Reference: https://doi.org/10.1103/PhysRevA.32.3266\n\nCircuit Representation\n\nq_0: ──■─────■──          \n       │   ┌─┴─┐\nq_1: ──■───┤ X ├\n     ┌─┴─┐ └───┘\nq_2: ┤ X ├──────\n     └───┘\n\nMatrix Representation\n\nPeresGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  0  0  1  0 \n            0  0  0  0  0  0  0  1 \n            0  0  0  0  0  1  0  0 \n            0  0  0  0  1  0  0  0 \n        endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"3_qubit_gates/#RCCXGate","page":"3-qubit gates","title":"RCCXGate","text":"","category":"section"},{"location":"3_qubit_gates/#QuantumCircuitOpt.RCCXGate","page":"3-qubit gates","title":"QuantumCircuitOpt.RCCXGate","text":"RCCXGate()\n\nThree-qubit relative (or simplified) Toffoli gate, or the CCX gate. This gate is equivalent to ToffoliGate upto relative phases.  The advantage of this gate is that it's implementation requires only three CNot (or CX) gates.  Reference: https://arxiv.org/pdf/1508.03273.pdf\n\nMatrix Representation\n\nRCCXGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  1  0  0  0 \n            0  0  0  0  0  -1  0  0 \n            0  0  0  0  0  0  0  -i \n            0  0  0  0  0  0  i  0 \n        endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"3_qubit_gates/#MargolusGate","page":"3-qubit gates","title":"MargolusGate","text":"","category":"section"},{"location":"3_qubit_gates/#QuantumCircuitOpt.MargolusGate","page":"3-qubit gates","title":"QuantumCircuitOpt.MargolusGate","text":"MargolusGate()\n\nThree-qubit Margolus gate, which is a simplified ToffoliGate and coincides with the Toffoli gate up  to a single change of sign. The advantage of this gate is that its implementation requires only three CNot (or CX) gates.  Reference: https://arxiv.org/pdf/quant-ph/0312225.pdf\n\nMatrix Representation\n\nMargolusGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  1  0  0  0 \n            0  0  0  0  0  -1  0  0 \n            0  0  0  0  0  0  0  1 \n            0  0  0  0  0  0  1  0 \n        endpmatrix\n\n\n\n\n\n","category":"function"},{"location":"3_qubit_gates/#CiSwapGate","page":"3-qubit gates","title":"CiSwapGate","text":"","category":"section"},{"location":"3_qubit_gates/#QuantumCircuitOpt.CiSwapGate","page":"3-qubit gates","title":"QuantumCircuitOpt.CiSwapGate","text":"CiSwapGate()\n\nThree-qubit controlled version of the iSwapGate. Reference: https://doi.org/10.1103/PhysRevResearch.2.033097\n\nCircuit Representation\n\nq_0: ─────■─────\n          │\n      ┌───────┐\nq_1: ─┤       ├─\n      │ iSwap │   \nq_2: ─┤       ├─ \n      └───────┘ \n\nMatrix Representation\n\nCiSwapGate =\n            beginpmatrix\n            1  0  0  0  0  0  0  0 \n            0  1  0  0  0  0  0  0 \n            0  0  1  0  0  0  0  0 \n            0  0  0  1  0  0  0  0 \n            0  0  0  0  1  0  0  0 \n            0  0  0  0  0  0  i  0 \n            0  0  0  0  0  i  0  0 \n            0  0  0  0  0  0  0  1 \n        endpmatrix\n\n\n\n\n\n","category":"function"}]
}
