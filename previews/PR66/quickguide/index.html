<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick Start guide · QuantumCircuitOpt.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link href="../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="QuantumCircuitOpt.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="QuantumCircuitOpt.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Quick Start guide</a><ul class="internal"><li><a class="tocitem" href="#Framework"><span>Framework</span></a></li><li><a class="tocitem" href="#Video-tutorials"><span>Video tutorials</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li class="toplevel"><a class="tocitem" href="#User-inputs"><span>User inputs</span></a></li><li class="toplevel"><a class="tocitem" href="#Optimization-model-inputs"><span>Optimization model inputs</span></a></li><li class="toplevel"><a class="tocitem" href="#Sample-circuit-synthesis"><span>Sample circuit synthesis</span></a></li><li class="toplevel"><a class="tocitem" href="#Extracting-results"><span>Extracting results</span></a></li><li class="toplevel"><a class="tocitem" href="#Visualizing-results"><span>Visualizing results</span></a></li></ul></li><li><span class="tocitem">Quantum Gates Library</span><ul><li><a class="tocitem" href="../1_qubit_gates/">1-qubit gates</a></li><li><a class="tocitem" href="../2_qubit_gates/">2-qubit gates</a></li><li><a class="tocitem" href="../3_qubit_gates/">3-qubit gates</a></li><li><a class="tocitem" href="../multi_qubit_gates/">Multi-qubit gates</a></li></ul></li><li><a class="tocitem" href="../function_references/">Function References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quick Start guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quick Start guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/master/docs/src/quickguide.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-Start-Guide"><a class="docs-heading-anchor" href="#Quick-Start-Guide">Quick Start Guide</a><a id="Quick-Start-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start-Guide" title="Permalink"></a></h1><h2 id="Framework"><a class="docs-heading-anchor" href="#Framework">Framework</a><a id="Framework-1"></a><a class="docs-heading-anchor-permalink" href="#Framework" title="Permalink"></a></h2><p>Building on the recent success of <a href="https://julialang.org">Julia</a>, <a href="https://github.com/jump-dev/JuMP.jl">JuMP</a> and mixed-integer programming (MIP) solvers, <a href="https://github.com/harshangrjn/QuantumCircuitOpt.jl">QuantumCircuitOpt</a> (or QCOpt), is an open-source toolkit for optimal quantum circuit design. As illustrated in the figure below, QCOpt is written in Julia, a relatively new and fast dynamic programming language used for technical computing with support for extensible type system and meta-programming. At a high level, QCOpt provides an abstraction layer to achieve two primary goals:</p><ol><li>To capture user-specified inputs, such as a desired quantum computation and the available hardware gates, and build a JuMP model of an MIP formulation, and </li><li>To extract, analyze and post-process the solution from the JuMP model to provide exact and approximate circuit decompositions, up to a global phase and machine precision.</li></ol><align="center"/>
<img width="550px" class="display-light-only" src="../assets/QCOpt_framework.png" alt="../assets/QCOpt_framework.png"/>
<img width="550px" class="display-dark-only" src="../assets/QCOpt_framework_dark.png" alt="../assets/QCOpt_framework.png"/><h2 id="Video-tutorials"><a class="docs-heading-anchor" href="#Video-tutorials">Video tutorials</a><a id="Video-tutorials-1"></a><a class="docs-heading-anchor-permalink" href="#Video-tutorials" title="Permalink"></a></h2><ul><li>July 2022: Presentation at the <a href="https://pretalx.com/juliacon-2022/talk/KJTGC3/">JuliaCon 2022</a> introduces the package in greater depth and how to use it&#39;s various features. </li></ul><align="center"/>
<a href="https://www.youtube.com/watch?v=OeONXwD4JJY">
    <img alt="Youtube-link" src="../assets/video_img_2.png"
    width=500" height="350">
</a><ul><li>November 2021: Presentation from the <a href="https://sc21.supercomputing.org/session/?sess=sess345">2nd Quantum Computing Software Workshop</a>, held in conjunction with the International Conference on Super Computing (<a href="https://sc21.supercomputing.org">SC21</a>), will introduce the technicalities underlying the package. </li></ul><align="center"/>
<a href="https://www.youtube.com/watch?v=sf1HJW5Vmio">
    <img alt="Youtube-link" src="../assets/video_img_1.png"
    width=500" height="350">
</a><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>To get started, install <a href="https://github.com/harshangrjn/QuantumCircuitOpt.jl">QCOpt</a> and <a href="https://github.com/jump-dev/JuMP.jl">JuMP</a>, a modeling language layer for optimization. QCOpt also needs a MIP solver such as <a href="https://github.com/jump-dev/Gurobi.jl">Gurobi</a> or IBM&#39;s <a href="https://github.com/jump-dev/CPLEX.jl">CPLEX</a>. If you prefer an open-source MIP solver, install <a href="https://github.com/jump-dev/HiGHS.jl">HiGHS</a> from the Julia package manager, though be warned that the run times of QCOpt can be substantially slower using any of the open-source MIP solvers. </p><h1 id="User-inputs"><a class="docs-heading-anchor" href="#User-inputs">User inputs</a><a id="User-inputs-1"></a><a class="docs-heading-anchor-permalink" href="#User-inputs" title="Permalink"></a></h1><p>QCOpt takes two types of user-defined input specifications. The first type of input contains all the necessary circuit specifications. This is given by a dictionary in Julia, which is a collection of key-value pairs, where every key is of the type <code>String</code>, which admits values of various types. Below is the list of allowable keys for the dictionary, given in column 1, and it&#39;s respective values with descriptions, given in column 2. This input dictionary is represented as <code>params</code> in all the <a href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/tree/master/examples">example</a> circuit decompositions. </p><table><tr><th style="text-align: right">Mandatory circuit specifications</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>num_qubits</code></td><td style="text-align: left">Number of qubits of the circuit (≥ 2).</td></tr><tr><td style="text-align: right"><code>maximum_depth</code></td><td style="text-align: left">Maximum allowable depth for decomposition of the circuit (≥ 2).</td></tr><tr><td style="text-align: right"><code>elementary_gates</code></td><td style="text-align: left">Vector of all one and two qubit elementary gates. The menagerie of quantum gates currently supported in QCOpt can be found in <a href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/master/src/gates.jl">gates.jl</a>.</td></tr><tr><td style="text-align: right"><code>target_gate</code></td><td style="text-align: left">Target unitary gate which you wish to decompose using the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>objective</code></td><td style="text-align: left">Choose one of the following: (a) <code>minimize_depth</code>, which minimizes the total number of one- and two-qubit gates. For this option, include <code>Identity</code> matrix in the above-mentioned <code>elementary_gates</code>, (b) <code>minimize_cnot</code>, which minimizes the number of CNOT gates in the decomposition. (default: <code>minimize_depth</code>)</td></tr><tr><td style="text-align: right"><code>decomposition_type</code></td><td style="text-align: left">Choose one of the following: (a) <code>exact_optimal</code>, which finds an exact, provably optimal, decomposition if it exists, (b) <code>exact_feasible</code>, which finds any feasible exact decomposition, but not necessarily an optimal one if it exists, (c) <code>optimal_global_phase</code>, which finds an optimal (best) circuit decomposition if it exists, up to a global phase (d) <code>approximate</code>, which finds an approximate decomposition if an exact one does not exist; otherwise it will return an exact decomposition (default: <code>exact_optimal</code>)</td></tr></table><p>If the above-specified <code>elementary_gates</code> contain gates with continuous angle parameters, then the following mandarotry input angle discretizations have to be specified in addition to the above inputs: </p><table><tr><th style="text-align: right">Mandatory angle discretizations</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>RX_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for <code>RXGate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>RY_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for <code>RYGate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>RZ_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for <code>RZGate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>Phase_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for <code>PhaseGate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>U3_θ_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for θ parameter in <code>U3Gate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>U3_ϕ_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for ϕ parameter in <code>U3Gate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>U3_λ_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for λ parameter in <code>U3Gate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>CRX_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for <code>CRXGate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>CRY_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for <code>CRYGate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>CRZ_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for <code>CRZGate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>CU3_θ_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for θ parameter in <code>CU3Gate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>CU3_ϕ_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for ϕ parameter in <code>CU3Gate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr><tr><td style="text-align: right"><code>CU3_λ_discretization</code></td><td style="text-align: left">Vector of discretization angles (in radians) for λ parameter in <code>CU3Gate</code>. Input this only if this gate is part of the above-mentioned <code>elementary_gates</code>.</td></tr></table><p>In addition, here is a list of <em>optional</em> circuit specifications, which can be added to the above set of inputs, to accelerate the performance of the QCOpt package:</p><table><tr><th style="text-align: right">Optional circuit specifications</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>initial_gate</code></td><td style="text-align: left">Intitial-condition gate to the decomposition (gate at 0th depth) (default: <code>Identity</code>).</td></tr><tr><td style="text-align: right"><code>set_cnot_lower_bound</code></td><td style="text-align: left">This option sets a lower bound on the total number of CNot or CX gates which an optimal decomposition can admit.</td></tr><tr><td style="text-align: right"><code>set_cnot_upper_bound</code></td><td style="text-align: left">This option sets an upper bound on the total number of CNot/CX gates which an optimal decomposition can admit. Note that both <code>set_cnot_lower_bound</code> and <code>set_cnot_upper_bound</code> can also be set to an identitcal value to fix the number of CNot/CX gates in the optimal decomposition.</td></tr><tr><td style="text-align: right"><code>input_circuit</code></td><td style="text-align: left">Input circuit representing an ensemble of elementary gates which decomposes the given target gate. This input circuit, which serves as a warm-start, can accelerate the MIP solver&#39;s search for the incumbent solution. (default: empty circuit).</td></tr></table><h1 id="Optimization-model-inputs"><a class="docs-heading-anchor" href="#Optimization-model-inputs">Optimization model inputs</a><a id="Optimization-model-inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-model-inputs" title="Permalink"></a></h1><p>The second set of inputs for QCOpt contains all the optional specifications for the underlying optimization models. This is given by a dictionary in Julia, which is a collection of key-value pairs, where every key is of the type <code>Symbol</code>, which admits values of various types. Below is the list of allowable keys for this dictionary, given in column 1, and it&#39;s respective values with descriptions, given in column 2. This input dictionary is an optional one, as it&#39;s default values are already set in <a href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/master/src/types.jl"><code>types.jl</code></a> correspnding to an optimal performance of the QCOpt package. Further, this dictionary is an optional argument while executing functions, <code>build_QCModel</code> and <code>run_QCModel</code> only.</p><table><tr><th style="text-align: right">Optional model inputs</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>model_type</code></td><td style="text-align: left">The type of implemented MIP model to optimize in QCOpt (default: <code>compact_formulation</code>).</td></tr><tr><td style="text-align: right"><code>commute_gate_constraints</code></td><td style="text-align: left">This option activates the valid constraints to eliminate pairs of commuting gates in the elementary (native) gates set (default: <code>true</code>)</td></tr><tr><td style="text-align: right"><code>involutory_gate_constraints</code></td><td style="text-align: left">This option activates the valid constraints to eliminate pairs of involutory gates in the elementary (native) gates set (default: <code>true</code>)</td></tr><tr><td style="text-align: right"><code>redundant_gate_pair_constraints</code></td><td style="text-align: left">This option activates the valid constraints to eliminate redundant pairs of gates in the elementary (native) gates set (default: <code>true</code>)</td></tr><tr><td style="text-align: right"><code>identity_gate_symmetry_constraints</code></td><td style="text-align: left">This option activates the valid constraints to eliminate symmetry in the Identity gate in the decomposition (default: <code>true</code>)</td></tr><tr><td style="text-align: right"><code>idempotent_gate_constraints</code></td><td style="text-align: left">This option activates the valid constraints to eliminate idempotent gates in the elementary (native) gates set (default: <code>false</code>)</td></tr><tr><td style="text-align: right"><code>convex_hull_gate_constraints</code></td><td style="text-align: left">This option activates the valid constraints to apply convex hull of complex entries in the elementary (native) gates set (default: <code>false</code>)</td></tr><tr><td style="text-align: right"><code>fix_unitary_variables</code></td><td style="text-align: left">This option evaluates all the fixed-valued indices of unitary matrix varaibles (<code>U_var</code>) at every depth, and appropriately builds the optimization model (default: <code>true</code>)</td></tr><tr><td style="text-align: right"><code>visualize_solution</code></td><td style="text-align: left">This option activates the visualization of the optimal circuit decomposition (default: <code>true</code>)</td></tr><tr><td style="text-align: right"><code>relax_integrality</code></td><td style="text-align: left">This option transforms integer variables into continuous variables (default: <code>false</code>).</td></tr><tr><td style="text-align: right"><code>optimizer_log</code></td><td style="text-align: left">This option enables or disables console logging for the <code>optimizer</code> (default: <code>true</code>).</td></tr><tr><td style="text-align: right"><code>objective_slack_penalty</code></td><td style="text-align: left">This option sets the penalty for minimizing the slack term in the objective, when <code>decomposition_type</code> is set to <code>approximate</code> (default: <code>1E3</code>).</td></tr><tr><td style="text-align: right"><code>time_limit</code></td><td style="text-align: left">This option allows sets the maximum time limit for the optimizer in seconds (default: <code>10,800</code>).</td></tr></table><h1 id="Sample-circuit-synthesis"><a class="docs-heading-anchor" href="#Sample-circuit-synthesis">Sample circuit synthesis</a><a id="Sample-circuit-synthesis-1"></a><a class="docs-heading-anchor-permalink" href="#Sample-circuit-synthesis" title="Permalink"></a></h1><p>Using the above-described mandatory and optional user inputs, here is a sample circuit decomposition to minimize the total depth for implementing a 2-qubit controlled-Z gate (<a href="https://harshangrjn.github.io/QuantumCircuitOpt.jl/dev/2_qubit_gates/#CZGate">CZGate</a>), with entangling <a href="https://harshangrjn.github.io/QuantumCircuitOpt.jl/dev/2_qubit_gates/#CNotGate">CNOT</a> gate and the one-qubit, universal rotation gate (<a href="https://harshangrjn.github.io/QuantumCircuitOpt.jl/dev/1_qubit_gates/#U3Gate">U3Gate</a>) with three discretized Euler angles (θ,ϕ,λ):</p><pre><code class="language-julia hljs">import QuantumCircuitOpt as QCOpt
using JuMP
using Gurobi

# Target: CZGate
function target_gate()
    return Array{Complex{Float64},2}([1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 -1]) 
end

# Circuit specifications (mandatory)
params = Dict{String, Any}(
&quot;num_qubits&quot; =&gt; 2, 
&quot;maximum_depth&quot; =&gt; 4,    
&quot;elementary_gates&quot; =&gt; [&quot;U3_1&quot;, &quot;U3_2&quot;, &quot;CNot_1_2&quot;, &quot;Identity&quot;],
&quot;target_gate&quot; =&gt; target_gate(),
&quot;objective&quot; =&gt; &quot;minimize_depth&quot;,
&quot;decomposition_type&quot; =&gt; &quot;exact_optimal&quot;,
       
&quot;U3_θ_discretization&quot; =&gt; -π:π/2:π,
&quot;U3_ϕ_discretization&quot; =&gt; -π:π/2:π,
&quot;U3_λ_discretization&quot; =&gt; -π:π/2:π,
)

# Optimization model inputs (optional)
model_options = Dict{Symbol, Any}(:model_type =&gt; &quot;compact_formulation&quot;,
                                  :visualize_solution =&gt; true)

qcm_optimizer = JuMP.optimizer_with_attributes(Gurobi.Optimizer, &quot;presolve&quot; =&gt; 1)
QCOpt.run_QCModel(params, qcm_optimizer; options = model_options)</code></pre><p>If you prefer to decompose a target gate of your choice, update the <code>target_gate()</code> function and the  set of <code>elementary_gates</code> accordingly in the above sample code. For more such circuit decompositions, with various types of elementary gates, refer to <a href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/tree/master/examples">examples</a> folder. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Note that <a href="https://github.com/harshangrjn/QuantumCircuitOpt.jl">QCOpt</a> tries to find the global minima of a specified objective function for a given set of input one- and two-qubit gates, target gate and the total depth of the decomposition. This combinatiorial optimization problem is known to be NP-hard to compute in the size of <code>num_qubits</code>, <code>maximum_depth</code> and <code>elementary_gates</code>. </p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Run times of <a href="https://github.com/harshangrjn/QuantumCircuitOpt.jl">QCOpt</a>&#39;s mathematical optimization models are significantly faster using <a href="https://www.gurobi.com">Gurobi</a> as the underlying mixed-integer programming (MIP) solver. Note that this solver&#39;s individual-usage license is available <a href="https://www.gurobi.com/academia/academic-program-and-licenses/">free</a> for academic purposes. </p></div></div><h1 id="Extracting-results"><a class="docs-heading-anchor" href="#Extracting-results">Extracting results</a><a id="Extracting-results-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-results" title="Permalink"></a></h1><p>The run commands (for example, <code>run_QCModel</code>) in QCOpt return detailed results in the form of a dictionary. This dictionary can be saved for further processing as follows,</p><pre><code class="language-julia hljs">results = QCOpt.run_QCModel(params, qcm_optimizer)</code></pre><p>For example, for decomposing the above controlled-Z gate, the QCOpt&#39;s runtime and the optimal objective value (minimum depth) can be accessed using,</p><pre><code class="language-julia hljs">results[&quot;solve_time&quot;]
results[&quot;objective&quot;]</code></pre><p>Also, <code>results[&quot;solution&quot;]</code> contains detailed information about the solution produced by the optimization model, which can be utilized for further analysis. </p><h1 id="Visualizing-results"><a class="docs-heading-anchor" href="#Visualizing-results">Visualizing results</a><a id="Visualizing-results-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-results" title="Permalink"></a></h1><p>QCOpt currently supports the visualization of optimal circuit decompositions obtained from the results dictionary (from above), which can be executed using,</p><pre><code class="language-julia hljs">data = QCOpt.get_data(params)
QCOpt.visualize_solution(results, data)</code></pre><p>For example, for the above controlled-Z gate decomposition, the processed output of QCOpt is as follows: </p><pre><code class="nohighlight hljs">=============================================================================
QuantumCircuitOpt version: v0.5.1

Quantum Circuit Model Data
  Number of qubits: 2
  Total number of elementary gates (after presolve): 72
  Maximum depth of decomposition: 4
  Elementary gates: [&quot;U3_1&quot;, &quot;U3_2&quot;, &quot;CNot_1_2&quot;, &quot;Identity&quot;]
    U3_θ discretization: [-180.0, -90.0, 0.0, 90.0, 180.0]
    U3_ϕ discretization: [-180.0, -90.0, 0.0, 90.0, 180.0]
    U3_λ discretization: [-180.0, -90.0, 0.0, 90.0, 180.0]
  Type of decomposition: exact_optimal
  MIP optimizer: Gurobi

Optimal Circuit Decomposition
  U3_2(-90.0,0.0,0.0) * CNot_1_2 * U3_2(90.0,0.0,0.0) = Target gate
  Minimum optimal depth: 3
  Optimizer run time: 3.01 sec.
=============================================================================</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../1_qubit_gates/">1-qubit gates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 3 February 2023 23:25">Friday 3 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
