<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function References · QuantumCircuitOpt.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link href="../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="QuantumCircuitOpt.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="QuantumCircuitOpt.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../quickguide/">Quick Start guide</a></li><li><span class="tocitem">Quantum Gates Library</span><ul><li><a class="tocitem" href="../1_qubit_gates/">1-qubit gates</a></li><li><a class="tocitem" href="../2_qubit_gates/">2-qubit gates</a></li><li><a class="tocitem" href="../3_qubit_gates/">3-qubit gates</a></li></ul></li><li class="is-active"><a class="tocitem" href>Function References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/master/docs/src/function_references.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantumCircuitOpt-Function-References"><a class="docs-heading-anchor" href="#QuantumCircuitOpt-Function-References">QuantumCircuitOpt Function References</a><a id="QuantumCircuitOpt-Function-References-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumCircuitOpt-Function-References" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.GateData" href="#QuantumCircuitOpt.GateData"><code>QuantumCircuitOpt.GateData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateData</code></pre><p>The composite mutable struct, <code>GateData</code>, type of the gate, the complex matrix form  of the gate, full sized real form of the gate, inverse of the gate and a boolean which states if the gate has all real entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/types.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.QCModelOptions" href="#QuantumCircuitOpt.QCModelOptions"><code>QuantumCircuitOpt.QCModelOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QCModelOptions</code></pre><p>The composite mutable struct, <code>QCModelOptions</code>, holds various optimization model options for enhancements  with defualt options set to the values provided by <code>get_default_options</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/types.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.QuantumCircuitModel" href="#QuantumCircuitOpt.QuantumCircuitModel"><code>QuantumCircuitOpt.QuantumCircuitModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuantumCircuitModel</code></pre><p>The composite mutable struct, <code>QuantumCircuitModel</code>, holds dictionaries for input data, abstract JuMP model for optimization, variable references and result from solving the JuMP model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/types.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CCZGate-Tuple{}" href="#QuantumCircuitOpt.CCZGate-Tuple{}"><code>QuantumCircuitOpt.CCZGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CCZGate()</code></pre><p>Three-qubit controlled-controlled Z gate. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ─■─
      │
q_1: ─■─
      │
q_2: ─■─</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CCZGate =
            \begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
        \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1645-L1674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CHGate-Tuple{}" href="#QuantumCircuitOpt.CHGate-Tuple{}"><code>QuantumCircuitOpt.CHGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CHGate()</code></pre><p>Two-qubit, symmetric, controlled Hadamard gate (<a href="../1_qubit_gates/#HGate">HGate</a>). </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──
     ┌─┴─┐  
q_1: ┤ H ├    
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CH = |0\rangle\langle 0| \otimes I + |1\rangle\langle 1| \otimes H = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
0 &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L732-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CHRevGate-Tuple{}" href="#QuantumCircuitOpt.CHRevGate-Tuple{}"><code>QuantumCircuitOpt.CHRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CHRevGate()</code></pre><p>Two-qubit reverse controlled-H gate, with target and control on first and second qubits, respectively. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌───┐
q_0: ┤ H ├
     └─┬─┘
q_1: ──■──</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CHRev = I \otimes |0\rangle\langle 0| + H \otimes |1\rangle\langle 1| = \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \frac{1}{\sqrt{2}} &amp; 0 &amp; \frac{1}{\sqrt{2}} \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; \frac{1}{\sqrt{2}} &amp; 0 &amp; -\frac{1}{\sqrt{2}}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L766-L789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CNotGate-Tuple{}" href="#QuantumCircuitOpt.CNotGate-Tuple{}"><code>QuantumCircuitOpt.CNotGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CNotGate()</code></pre><p>Two-qubit controlled NOT gate with control and target on first and second qubits, respectively. This is also  called the controlled X gate (<a href="../2_qubit_gates/#CXGate">CXGate</a>). </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──
     ┌─┴─┐
q_1: ┤ X ├
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CNot = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L439-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CNotRevGate-Tuple{}" href="#QuantumCircuitOpt.CNotRevGate-Tuple{}"><code>QuantumCircuitOpt.CNotRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CNotRevGate()</code></pre><p>Two-qubit reverse controlled NOT gate, with target and control on first and second qubits, respectively. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌───┐
q_0: ┤ X ├
     └─┬─┘
q_1: ──■──</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CNotRev = \begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 1 \\
            0 &amp; 0 &amp; 1 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0
            \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L470-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CRXGate-Tuple{Number}" href="#QuantumCircuitOpt.CRXGate-Tuple{Number}"><code>QuantumCircuitOpt.CRXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRXGate(θ::Number)</code></pre><p>Two-qubit controlled <a href="../1_qubit_gates/#RXGate">RXGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ────■────
     ┌───┴───┐
q_1: ┤ RX(ϴ) ├
     └───────┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CRX(\theta)\ q_1, q_0 =
|0\rangle\langle0| \otimes I + |1\rangle\langle1| \otimes RX(\theta) =
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; \cos{\th}   &amp; -i\sin{\th} \\
        0 &amp; 0 &amp; -i\sin{\th} &amp; \cos{\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L944-L971">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CRXRevGate-Tuple{Number}" href="#QuantumCircuitOpt.CRXRevGate-Tuple{Number}"><code>QuantumCircuitOpt.CRXRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRXRevGate(θ::Number)</code></pre><p>Two-qubit controlled reverse <a href="../1_qubit_gates/#RXGate">RXGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌───────┐
q_1: ┤ RX(ϴ) ├
     └───┬───┘
q_0: ────■────</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CRXRev(\theta)\ q_1, q_0 =
|0\rangle\langle0| \otimes I + |1\rangle\langle1| \otimes RX(\theta) =
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \cos{\th} &amp; 0 &amp; -i\sin{\th} \\
        0 &amp; 0 &amp; 1 &amp; 0\\
        0 &amp; -i\sin{\th} &amp; 0 &amp; \cos{\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L982-L1009">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CRYGate-Tuple{Number}" href="#QuantumCircuitOpt.CRYGate-Tuple{Number}"><code>QuantumCircuitOpt.CRYGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRYGate(θ::Number)</code></pre><p>Two-qubit controlled <a href="../1_qubit_gates/#RYGate">RYGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ────■────
     ┌───┴───┐
q_1: ┤ RY(ϴ) ├
     └───────┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CRY(\theta)\ q_1, q_0 =
|0\rangle\langle0| \otimes I + |1\rangle\langle1| \otimes RY(\theta) =
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; \cos{\th}   &amp; -\sin{\th} \\
        0 &amp; 0 &amp; \sin{\th} &amp; \cos{\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1020-L1047">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CRYRevGate-Tuple{Number}" href="#QuantumCircuitOpt.CRYRevGate-Tuple{Number}"><code>QuantumCircuitOpt.CRYRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRYRevGate(θ::Number)</code></pre><p>Two-qubit controlled reverse <a href="../1_qubit_gates/#RYGate">RYGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌───────┐
q_1: ┤ RY(ϴ) ├
     └───┬───┘
q_0: ────■────</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CRYRev(\theta)\ q_1, q_0 =
|0\rangle\langle0| \otimes I + |1\rangle\langle1| \otimes RY(\theta) =
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \cos{\th} &amp; 0 &amp; -\sin{\th} \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; \sin{\th} &amp; 0 &amp; \cos{\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1060-L1087">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CRZGate-Tuple{Number}" href="#QuantumCircuitOpt.CRZGate-Tuple{Number}"><code>QuantumCircuitOpt.CRZGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRZGate(θ::Number)</code></pre><p>Two-qubit controlled <a href="../1_qubit_gates/#RZGate">RZGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ────■────
     ┌───┴───┐
q_1: ┤ RZ(ϴ) ├
     └───────┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CRZ(\theta)\ q_1, q_0 =
|0\rangle\langle0| \otimes I + |1\rangle\langle1| \otimes RZ(\theta) =
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; e^{-i\th}  &amp;  0 \\
        0 &amp; 0 &amp; 0 &amp; e^{i\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1100-L1127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CRZRevGate-Tuple{Number}" href="#QuantumCircuitOpt.CRZRevGate-Tuple{Number}"><code>QuantumCircuitOpt.CRZRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRZRevGate(θ::Number)</code></pre><p>Two-qubit controlled reverse <a href="../1_qubit_gates/#RZGate">RZGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌───────┐
q_1: ┤ RZ(ϴ) ├
     └───┬───┘
q_0: ────■────</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CRZRev(\theta)\ q_1, q_0 =
|0\rangle\langle0| \otimes I + |1\rangle\langle1| \otimes RZ(\theta) =
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; e^{-i\th} &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 1 &amp;  0 \\
        0 &amp; 0 &amp; 0 &amp; e^{i\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1140-L1167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CSXGate-Tuple{}" href="#QuantumCircuitOpt.CSXGate-Tuple{}"><code>QuantumCircuitOpt.CSXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSXGate()</code></pre><p>Two-qubit controlled version of (<a href="../1_qubit_gates/#SXGate">SXGate</a>). </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ─────■─────
     ┌────┴────┐
q_1: ┤ sqrt(X) ├
     └─────────┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CSXGate = |0 \rangle\langle 0| \otimes I + |1 \rangle\langle 1| \otimes SX = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0.5+0.5i &amp; 0.5-0.5i \\
0 &amp; 0 &amp; 0.5-0.5i &amp; 0.5+0.5i
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1332-L1355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CSXRevGate-Tuple{}" href="#QuantumCircuitOpt.CSXRevGate-Tuple{}"><code>QuantumCircuitOpt.CSXRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSXRevGate()</code></pre><p>Two-qubit controlled version of the reverse (<a href="../1_qubit_gates/#SXGate">SXGate</a>). </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌─────────┐
q_1: ┤ sqrt(X) ├
     └────┬────┘
q_0: ─────■────</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CSXRevGate = I \otimes |0\rangle\langle 0| + SX \otimes |1\rangle\langle 1| = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0.5+0.5i &amp; 0 &amp; 0.5-0.5i \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0.5-0.5i &amp; 0 &amp; 0.5+0.5i
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1366-L1389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CSwapGate-Tuple{}" href="#QuantumCircuitOpt.CSwapGate-Tuple{}"><code>QuantumCircuitOpt.CSwapGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSwapGate()</code></pre><p>Three-qubit, controlled <a href="../2_qubit_gates/#SwapGate">SwapGate</a>, also known as the <a href="https://en.wikipedia.org/wiki/Fredkin_gate">Fredkin gate</a>.</p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ─■─
      │
q_1: ─X─
      │
q_2: ─X─</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CSwapGate =
            \begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
        \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1602-L1631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CU3Gate-Tuple{Number, Number, Number}" href="#QuantumCircuitOpt.CU3Gate-Tuple{Number, Number, Number}"><code>QuantumCircuitOpt.CU3Gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CU3Gate(θ::Number, ϕ::Number, λ::Number)</code></pre><p>Two-qubit, controlled version of the universal rotation gate with three Euler angles (<a href="../1_qubit_gates/#U3Gate">U3Gate</a>). </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──────■──────
     ┌─────┴─────┐
q_1: ┤ U3(ϴ,φ,λ) ├
     └───────────┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CU3(\theta, \phi, \lambda)\ q_1, q_0 =
                |0\rangle\langle 0| \otimes I +
                |1\rangle\langle 1| \otimes U3(\theta,\phi,\lambda) =
                \begin{pmatrix}
                    1 &amp; 0   &amp; 0                  &amp; 0 \\
                    0 &amp; 1   &amp; 0                  &amp; 0 \\
                    0 &amp; 0   &amp; \cos(\th)          &amp; -e^{i\lambda}\sin(\th) \\
                    0 &amp; 0   &amp; e^{i\phi}\sin(\th) &amp; e^{i(\phi+\lambda)}\cos(\th)
                \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1180-L1208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CU3RevGate-Tuple{Number, Number, Number}" href="#QuantumCircuitOpt.CU3RevGate-Tuple{Number, Number, Number}"><code>QuantumCircuitOpt.CU3RevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CU3RevGate(θ::Number, ϕ::Number, λ::Number)</code></pre><p>Two-qubit, reverse controlled version of the universal rotation gate with three Euler angles (<a href="../1_qubit_gates/#U3Gate">U3Gate</a>). </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌────────────┐
q_1: ┤  U3(ϴ,φ,λ) ├
     └──────┬─────┘
q_0: ───────■──────</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CU3(\theta, \phi, \lambda)\ q_1, q_0 =
                |0\rangle\langle 0| \otimes I +
                |1\rangle\langle 1| \otimes U3(\theta,\phi,\lambda) =
                \begin{pmatrix}
                    1 &amp; 0   &amp; 0  &amp; 0 \\
                    0 &amp; \cos(\th)   &amp; 0 &amp; -e^{i\lambda}\sin(\th) \\
                    0 &amp; 0   &amp;  1 &amp; 0 \\
                    0 &amp; e^{i\phi}\sin(\th)  &amp; 0  &amp; e^{i(\phi+\lambda)}\cos(\th)
                \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1223-L1251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CVGate-Tuple{}" href="#QuantumCircuitOpt.CVGate-Tuple{}"><code>QuantumCircuitOpt.CVGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CVGate()</code></pre><p>Two-qubit, controlled-V gate, which is also the same as Controlled square-root of X gate (<a href="../2_qubit_gates/#CSXGate">CSXGate</a>).  </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──     
     ┌─┴─┐    
q_1: ┤ V ├     
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CV = \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 0.5+0.5i &amp; 0.5-0.5i \\
        0 &amp; 0 &amp; 0.5-0.5i &amp; 0.5+0.5i
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L800-L823">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CVRevGate-Tuple{}" href="#QuantumCircuitOpt.CVRevGate-Tuple{}"><code>QuantumCircuitOpt.CVRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CVRevGate()</code></pre><p>Two-qubit reverse controlled-V gate, with target and control on first and second qubits, respectively. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌───┐
q_0: ┤ V ├
     └─┬─┘
q_1: ──■──</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CVRev = \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 0.5+0.5i &amp; 0 &amp; 0.5-0.5i \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; 0.5-0.5i &amp; 0 &amp; 0.5+0.5i
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L831-L854">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CVdaggerGate-Tuple{}" href="#QuantumCircuitOpt.CVdaggerGate-Tuple{}"><code>QuantumCircuitOpt.CVdaggerGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CVdaggerGate()</code></pre><p>Two-qubit hermitian conjugate of controlled-V gate, which is also the same as hermitian conjugate Controlled square-root of X gate (<a href="../2_qubit_gates/#CSXGate">CSXGate</a>).  </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──     
     ┌─┴─┐    
q_1: ┤ V&#39;├     
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CVdagger = \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 0.5-0.5i &amp; 0.5+0.5i \\
        0 &amp; 0 &amp; 0.5+0.5i &amp; 0.5-0.5i
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L861-L884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CVdaggerRevGate-Tuple{}" href="#QuantumCircuitOpt.CVdaggerRevGate-Tuple{}"><code>QuantumCircuitOpt.CVdaggerRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CVdaggerRevGate()</code></pre><p>Two-qubit hermitian conjugate of reverse controlled-V gate, with target and control on first and second qubits, respectively. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌───┐
q_0: ┤ V&#39;├
     └─┬─┘
q_1: ──■──</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CVdaggerRev = \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 0.5-0.5i &amp; 0 &amp; 0.5+0.5i \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; 0.5+0.5i &amp; 0 &amp; 0.5-0.5i
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L892-L915">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CXGate-Tuple{}" href="#QuantumCircuitOpt.CXGate-Tuple{}"><code>QuantumCircuitOpt.CXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CXGate()</code></pre><p>Two-qubit controlled <a href="../1_qubit_gates/#XGate">XGate</a>, which is also the same as <a href="../2_qubit_gates/#CNotGate">CNotGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──
     ┌─┴─┐
q_1: ┤ X ├
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CX = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L531-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CXRevGate-Tuple{}" href="#QuantumCircuitOpt.CXRevGate-Tuple{}"><code>QuantumCircuitOpt.CXRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CXRevGate()</code></pre><p>Two-qubit reverse controlled-X gate, with target and control on first and second qubits, respectively.  This is also the same as <a href="../2_qubit_gates/#CNotRevGate">CNotRevGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌───┐
q_0: ┤ X ├
     └─┬─┘
q_1: ──■──</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CXRev = I \otimes |0 \rangle\langle 0| + X \otimes |1 \rangle\langle 1| = \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1 \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L561-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CYGate-Tuple{}" href="#QuantumCircuitOpt.CYGate-Tuple{}"><code>QuantumCircuitOpt.CYGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CYGate()</code></pre><p>Two-qubit controlled <a href="../1_qubit_gates/#YGate">YGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──
     ┌─┴─┐
q_1: ┤ Y ├
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CY = |0 \rangle\langle 0| \otimes I + |1 \rangle\langle 1| \otimes Y = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -i \\
    0 &amp; 0 &amp; i &amp; 0
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L596-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CYRevGate-Tuple{}" href="#QuantumCircuitOpt.CYRevGate-Tuple{}"><code>QuantumCircuitOpt.CYRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CYRevGate()</code></pre><p>Two-qubit reverse controlled-Y gate, with target and control on first and second qubits, respectively. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌───┐
q_0: ┤ Y ├
     └─┬─┘
q_1: ──■──</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CYRev = I \otimes |0 \rangle\langle 0| + Y \otimes |1 \rangle\langle 1| = \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; -i \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; i &amp; 0 &amp; 0
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L630-L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CZGate-Tuple{}" href="#QuantumCircuitOpt.CZGate-Tuple{}"><code>QuantumCircuitOpt.CZGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CZGate()</code></pre><p>Two-qubit, symmetric, controlled <a href="../1_qubit_gates/#ZGate">ZGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──     ─■─
     ┌─┴─┐  ≡   │
q_1: ┤ Z ├     ─■─
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CZ = |0 \rangle\langle 0| \otimes I + |1 \rangle\langle 1| \otimes Z = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L664-L687">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CZRevGate-Tuple{}" href="#QuantumCircuitOpt.CZRevGate-Tuple{}"><code>QuantumCircuitOpt.CZRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CZRevGate()</code></pre><p>Two-qubit reverse controlled-Z gate, with target and control on first and second qubits, respectively. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌───┐
q_0: ┤ Z ├
     └─┬─┘
q_1: ──■──</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CZRev = I \otimes |0\rangle\langle0| + Z \otimes |1\rangle\langle1| = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L698-L721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.DCXGate-Tuple{}" href="#QuantumCircuitOpt.DCXGate-Tuple{}"><code>QuantumCircuitOpt.DCXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DCXGate()</code></pre><p>Two-qubit double controlled NOT gate consisting of two back-to-back <a href="../2_qubit_gates/#CNotGate">CNotGate</a>s with alternate controls. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">          ┌───┐
q_0: ──■──┤ X ├
     ┌─┴─┐└─┬─┘
q_1: ┤ X ├──■──
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[DCX = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L500-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.GroverDiffusionGate-Tuple{}" href="#QuantumCircuitOpt.GroverDiffusionGate-Tuple{}"><code>QuantumCircuitOpt.GroverDiffusionGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GroverDiffusionGate()</code></pre><p>Two-qubit, Grover&#39;s diffusion operator, a key building block of the Glover&#39;s algorithm used to find a specific item (with probability &gt; 0.5) within a randomly ordered database of N items in O(sqrt(N)) operations.  Reference: <a href="https://arxiv.org/pdf/1804.03719.pdf">https://arxiv.org/pdf/1804.03719.pdf</a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[GroverDiffusionGate = \frac{1}{2}\begin{pmatrix}
1 &amp; -1 &amp; -1 &amp; -1 \\
-1 &amp; 1 &amp; -1 &amp; -1 \\
-1 &amp; -1 &amp; 1 &amp; -1 \\ 
-1 &amp; -1 &amp; -1 &amp; 1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1492-L1509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.HCoinGate-Tuple{}" href="#QuantumCircuitOpt.HCoinGate-Tuple{}"><code>QuantumCircuitOpt.HCoinGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HCoinGate()</code></pre><p>Two-qubit, Hadamard Coin gate when implemented in tune with the quantum cellular automata.  Reference: <a href="https://doi.org/10.1007/s11128-018-1983-x">https://doi.org/10.1007/s11128-018-1983-x</a>, <a href="https://arxiv.org/pdf/2106.03115.pdf">https://arxiv.org/pdf/2106.03115.pdf</a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[HCoinGate = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; 0 \\
0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1469-L1485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.HGate-Tuple{}" href="#QuantumCircuitOpt.HGate-Tuple{}"><code>QuantumCircuitOpt.HGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HGate(num_qubits::Int64)</code></pre><p>Single-qubit Hadamard gate, which is a <span>$\pi$</span> rotation about the X+Z axis, thus equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$\frac{\pi}{2},0,\pi$</span>)</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[H = \frac{1}{\sqrt{2}}
        \begin{pmatrix}
            1 &amp; 1 \\
            1 &amp; -1
        \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L211-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.IGate-Tuple{Int64}" href="#QuantumCircuitOpt.IGate-Tuple{Int64}"><code>QuantumCircuitOpt.IGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IGate(num_qubits::Int64)</code></pre><p>Identity matrix for an input number of qubits.</p><p><strong>Matrix Representation (num_qubits = 1)</strong></p><p class="math-container">\[I = \begin{pmatrix}
        1 &amp; 0 \\
        0 &amp; 1
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L36-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.MGate-Tuple{}" href="#QuantumCircuitOpt.MGate-Tuple{}"><code>QuantumCircuitOpt.MGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MGate()</code></pre><p>Two-qubit Magic gate, also known as the Ising coupling or the XX gate.</p><p>Reference: <a href="https://doi.org/10.1103/PhysRevA.69.032315">https://doi.org/10.1103/PhysRevA.69.032315</a></p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">      ┌───┐        ┌───┐
q_0: ─┤ X ├────────┤ S ├
      └─┬─┘        └─┬─┘        
        │   ┌───┐  ┌─┴─┐
q_1: ───■───┤ H ├──┤ S ├
            └───┘  └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[M = \frac{1}{\sqrt{2}} \begin{pmatrix}
1 &amp; i &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; i &amp; 1 \\
0 &amp; 0 &amp; i &amp; -1 \\
1 &amp; -i &amp; 0 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1401-L1428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.PeresGate-Tuple{}" href="#QuantumCircuitOpt.PeresGate-Tuple{}"><code>QuantumCircuitOpt.PeresGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PeresGate()</code></pre><p>Three-qubit Peres gate. This gate is equivalent to <a href="../3_qubit_gates/#ToffoliGate">ToffoliGate</a> followed by the <a href="../2_qubit_gates/#CNotGate">CNotGate</a> in 3 qubits.  Reference: <a href="https://doi.org/10.1103/PhysRevA.32.3266">https://doi.org/10.1103/PhysRevA.32.3266</a></p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■─────■──          
       │   ┌─┴─┐
q_1: ──■───┤ X ├
     ┌─┴─┐ └───┘
q_2: ┤ X ├──────
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[PeresGate =
            \begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
        \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1688-L1719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.PhaseGate-Tuple{Number}" href="#QuantumCircuitOpt.PhaseGate-Tuple{Number}"><code>QuantumCircuitOpt.PhaseGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PhaseGate()</code></pre><p>Single-qubit rotation gate about the Z axis. This is also equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$0,0,\lambda$</span>). This  gate is also referred to as the <a href="../1_qubit_gates/#U1Gate">U1Gate</a>. </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[P(\lambda) = \begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; e^{i\lambda}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L417-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.QFT2Gate-Tuple{}" href="#QuantumCircuitOpt.QFT2Gate-Tuple{}"><code>QuantumCircuitOpt.QFT2Gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QFT2Gate()</code></pre><p>Two-qubit Quantum Fourier Transform (QFT) gate, where the QFT operation on n-qubits is given by: </p><p class="math-container">\[|j\rangle \mapsto \frac{1}{2^{n/2}} \sum_{k=0}^{2^n - 1} e^{2\pi ijk / 2^n} |k\rangle\]</p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌──────┐
q_0: ┤      ├
     │ QFT2 │   
q_1: ┤      ├ 
     └──────┘ </code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[M = \frac{1}{2} \begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; i &amp; -1 &amp; -i \\
1 &amp; -1 &amp; 1 &amp; -1 \\
1 &amp; -i &amp; -1 &amp; i
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1435-L1462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.RXGate-Tuple{Number}" href="#QuantumCircuitOpt.RXGate-Tuple{Number}"><code>QuantumCircuitOpt.RXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RXGate(θ::Number)</code></pre><p>A single-qubit Pauli gate which represents rotation about the X axis.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

RX(\theta) = exp(-i \th X) =
    \begin{pmatrix}
        \cos{\th}   &amp; -i\sin{\th} \\
        -i\sin{\th} &amp; \cos{\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L135-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.RYGate-Tuple{Number}" href="#QuantumCircuitOpt.RYGate-Tuple{Number}"><code>QuantumCircuitOpt.RYGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RYGate(θ::Number)</code></pre><p>A single-qubit Pauli gate which represents rotation about the Y axis.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

RY(\theta) = exp(-i \th Y) =
    \begin{pmatrix}
        \cos{\th} &amp; -\sin{\th} \\
        \sin{\th} &amp; \cos{\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L160-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.RZGate-Tuple{Number}" href="#QuantumCircuitOpt.RZGate-Tuple{Number}"><code>QuantumCircuitOpt.RZGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RZGate(θ::Number)</code></pre><p>A single-qubit Pauli gate which represents rotation about the Z axis. This gate is also equivalent to <a href="../1_qubit_gates/#U1Gate">U1Gate</a> up to a phase factor,  that is, <span>$RZ(\theta) = e^{-i{\theta}/2}U1(\theta)$</span>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

RZ(\theta) = exp(-i\th Z) =
\begin{pmatrix}
    e^{-i\th} &amp; 0 \\
    0 &amp; e^{i\th}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L185-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.SGate-Tuple{}" href="#QuantumCircuitOpt.SGate-Tuple{}"><code>QuantumCircuitOpt.SGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SGate()</code></pre><p>Single-qubit S gate, equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$0,0,\frac{\pi}{2}$</span>). This  gate is also referred to as a Clifford gate, P gate or a square-root of Pauli-<a href="../1_qubit_gates/#ZGate">ZGate</a>. Historically, this is also  called as the phase gate (denoted by P), since it shifts the phase of the one state relative to the zero state.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[S = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; i
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L292-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.SXGate-Tuple{}" href="#QuantumCircuitOpt.SXGate-Tuple{}"><code>QuantumCircuitOpt.SXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SXGate()</code></pre><p>Single-qubit square root of pauli-<a href="../1_qubit_gates/#XGate">XGate</a>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\sqrt{X} = \frac{1}{2} \begin{pmatrix}
1 + i &amp; 1 - i \\
1 - i &amp; 1 + i
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L377-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.SXdaggerGate-Tuple{}" href="#QuantumCircuitOpt.SXdaggerGate-Tuple{}"><code>QuantumCircuitOpt.SXdaggerGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SXdaggerGate()</code></pre><p>Single-qubit hermitian conjugate of the square root of pauli-<a href="../1_qubit_gates/#XGate">XGate</a>, or the <a href="../1_qubit_gates/#SXGate">SXGate</a>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\sqrt{X}^{\dagger} = \frac{1}{2} \begin{pmatrix}
1 - i &amp; 1 + i \\
1 + i &amp; 1 - i
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L397-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.SdaggerGate-Tuple{}" href="#QuantumCircuitOpt.SdaggerGate-Tuple{}"><code>QuantumCircuitOpt.SdaggerGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SdaggerGate()</code></pre><p>Single-qubit, hermitian conjugate of the <a href="../1_qubit_gates/#SGate">SGate</a>. This is also an alternative square root of  the <a href="../1_qubit_gates/#ZGate">ZGate</a>. </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[S = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; -i
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L314-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.SwapGate-Tuple{}" href="#QuantumCircuitOpt.SwapGate-Tuple{}"><code>QuantumCircuitOpt.SwapGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SwapGate()</code></pre><p>Two-qubit, symmetric, SWAP gate. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ─X─
      │
q_1: ─X─</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[SWAP = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1266-L1288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.SycamoreGate-Tuple{}" href="#QuantumCircuitOpt.SycamoreGate-Tuple{}"><code>QuantumCircuitOpt.SycamoreGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SycamoreGate()</code></pre><p>Two-qubit Sycamore Gate, native to Google&#39;s universal quantum processor. Reference: <a href="https://quantumai.google/cirq/google/devices">quantumai.google/cirq/google/devices</a></p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌──────┐
q_0: ┤      ├
     │ SYC  │   
q_1: ┤      ├ 
     └──────┘ </code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[
SycamoreGate() = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -i &amp; 0 \\
0 &amp; -i &amp; 0 &amp; 0 \\ 
0 &amp; 0 &amp; 0 &amp; e^{-i \frac{\pi}{6}}
\end{pmatrix}
\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1516-L1543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.TGate-Tuple{}" href="#QuantumCircuitOpt.TGate-Tuple{}"><code>QuantumCircuitOpt.TGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TGate()</code></pre><p>Single-qubit T gate, equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$0,0,\frac{\pi}{4}$</span>). This  gate is also referred to as a <span>$\frac{\pi}{8}$</span> gate or as a fourth-root of Pauli-<a href="../1_qubit_gates/#ZGate">ZGate</a>. </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[T = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; e^{i\pi/4}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L335-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.TdaggerGate-Tuple{}" href="#QuantumCircuitOpt.TdaggerGate-Tuple{}"><code>QuantumCircuitOpt.TdaggerGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TdaggerGate()</code></pre><p>Single-qubit, hermitian conjugate of the <a href="../1_qubit_gates/#TGate">TGate</a>. This gate is equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$0,0,-\frac{\pi}{4}$</span>). This  gate is also referred to as the fourth-root of Pauli-<a href="../1_qubit_gates/#ZGate">ZGate</a>. </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[T^{\dagger} = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; e^{-i\pi/4}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L356-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.ToffoliGate-Tuple{}" href="#QuantumCircuitOpt.ToffoliGate-Tuple{}"><code>QuantumCircuitOpt.ToffoliGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ToffoliGate()</code></pre><p>Three-qubit Toffoli gate, also known as the CCX (controlled-controlled-NOT) gate. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──
       │
q_1: ──■──
     ┌─┴─┐
q_2: ┤ X ├
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[Toffoli     =
            |0 \rangle \langle 0| \otimes I \otimes I + |1 \rangle \langle 1| \otimes CXGate =
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
                0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
                0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
                0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
            \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1557-L1588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.U1Gate-Tuple{Number}" href="#QuantumCircuitOpt.U1Gate-Tuple{Number}"><code>QuantumCircuitOpt.U1Gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">U1Gate(λ::Number)</code></pre><p>Universal single-qubit rotation gate with one Euler angle, <span>$\lambda$</span>. U1Gate represents rotation about the Z axis and  is the special case of <a href="../1_qubit_gates/#U3Gate">U3Gate</a>, which also known as the <a href="../1_qubit_gates/#PhaseGate">PhaseGate</a>. Also note that <span>$U1(\pi) =$</span><a href="../1_qubit_gates/#ZGate">ZGate</a>, <span>$U1(\pi/2) =$</span><a href="../1_qubit_gates/#SGate">SGate</a> and  <span>$U1(\pi/4) =$</span><a href="../1_qubit_gates/#TGate">TGate</a>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[U1(\lambda) =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; e^{i\lambda}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L109-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.U2Gate-Tuple{Number, Number}" href="#QuantumCircuitOpt.U2Gate-Tuple{Number, Number}"><code>QuantumCircuitOpt.U2Gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">U2Gate(ϕ::Number, λ::Number)</code></pre><p>Universal single-qubit rotation gate with two Euler angles, <span>$\phi$</span> and <span>$\lambda$</span>. U2Gate is the special case of  <a href="../1_qubit_gates/#U3Gate">U3Gate</a>. </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[U2(\phi, \lambda) = \frac{1}{\sqrt{2}}
\begin{pmatrix}
    1          &amp; -e^{i\lambda} \\
    e^{i\phi} &amp; e^{i(\phi+\lambda)}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L85-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.U3Gate-Tuple{Number, Number, Number}" href="#QuantumCircuitOpt.U3Gate-Tuple{Number, Number, Number}"><code>QuantumCircuitOpt.U3Gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">U3Gate(θ::Number, ϕ::Number, λ::Number)</code></pre><p>Universal single-qubit rotation gate with three Euler angles, <span>$\theta$</span>, <span>$\phi$</span> and <span>$\lambda$</span>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

U3(\theta, \phi, \lambda) =
    \begin{pmatrix}
        \cos(\th)          &amp; -e^{i\lambda}\sin(\th) \\
        e^{i\phi}\sin(\th) &amp; e^{i(\phi+\lambda)}\cos(\th)
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L56-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.WGate-Tuple{}" href="#QuantumCircuitOpt.WGate-Tuple{}"><code>QuantumCircuitOpt.WGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WGate()</code></pre><p>Two-qubit, W hermitian gate, typically useful to diagonlize the (<a href="../2_qubit_gates/#SwapGate">SwapGate</a>).  </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[W = \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; 0 \\
        0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}} &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L922-L937">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.XGate-Tuple{}" href="#QuantumCircuitOpt.XGate-Tuple{}"><code>QuantumCircuitOpt.XGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XGate()</code></pre><p>Single-qubit Pauli-X gate (<span>$\sigma_x$</span>), equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$\pi,0,\pi$</span>)</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[X = \begin{pmatrix}
0 &amp; 1 \\
1 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L232-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.YGate-Tuple{}" href="#QuantumCircuitOpt.YGate-Tuple{}"><code>QuantumCircuitOpt.YGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">YGate()</code></pre><p>Single-qubit Pauli-Y gate (<span>$\sigma_y$</span>), equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$\pi,\frac{\pi}{2},\frac{\pi}{2}$</span>)</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[Y = \begin{pmatrix}
0 &amp; -i \\
i &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L252-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.ZGate-Tuple{}" href="#QuantumCircuitOpt.ZGate-Tuple{}"><code>QuantumCircuitOpt.ZGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZGate()</code></pre><p>Single-qubit Pauli-Z gate (<span>$\sigma_z$</span>), equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$0,0,\pi$</span>)</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[Z = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; -1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L272-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt._catch_input_gate_errors-Tuple{String, Vector{Int64}, Int64, String}" href="#QuantumCircuitOpt._catch_input_gate_errors-Tuple{String, Vector{Int64}, Int64, String}"><code>QuantumCircuitOpt._catch_input_gate_errors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_catch_input_gate_errors(gate_type::String, qubit_loc::Vector{Int64}, num_qubits::Int64, input_gate::String)</code></pre><p>Given an input gate string, number of qubits of the circuit and the qubit locations for the input gate,  this function catches and throws any errors, should the input gate type and qubits are invalid. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/data.jl#L634-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt._get_constraint_slope_intercept-Tuple{Tuple{Number, Number}, Tuple{Number, Number}}" href="#QuantumCircuitOpt._get_constraint_slope_intercept-Tuple{Tuple{Number, Number}, Tuple{Number, Number}}"><code>QuantumCircuitOpt._get_constraint_slope_intercept</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_get_constraint_slope_intercept(vertex1::Vector{&lt;:Number}, vertex2::Vector{&lt;:Number})</code></pre><p>Given co-ordinates of two points in a plane, this function returns the slope (m) and intercept (c) of the  line joining these two points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L596-L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt._lt_filter-Tuple{Tuple{Number, Number}, Tuple{Number, Number}}" href="#QuantumCircuitOpt._lt_filter-Tuple{Tuple{Number, Number}, Tuple{Number, Number}}"><code>QuantumCircuitOpt._lt_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_lt_filter(a::Tuple{&lt;:Number, &lt;:Number}, b::Tuple{&lt;:Number, &lt;:Number})</code></pre><p>Utility function for sorting step in <code>convex_hull</code>. Given two points, <code>a</code> and <code>b</code>, this function  returns true if <code>a</code> has larger polar angle (counterclock-wise direction) than <code>b</code> w.r.t. first point <code>chull_p1</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/chull.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt._orientation-Tuple{Tuple{Number, Number}, Tuple{Number, Number}, Tuple{Number, Number}}" href="#QuantumCircuitOpt._orientation-Tuple{Tuple{Number, Number}, Tuple{Number, Number}, Tuple{Number, Number}}"><code>QuantumCircuitOpt._orientation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_orientation(x::Tuple{&lt;:Number, &lt;:Number}, y::Tuple{&lt;:Number, &lt;:Number}, z::Tuple{&lt;:Number, &lt;:Number})</code></pre><p>Utility function for <code>convex_hull</code>. Given an ordered triplet, this function returns if three points are collinear, oriented in clock-wise or anticlock-wise direction. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/chull.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt._parse_gate_string-Tuple{String}" href="#QuantumCircuitOpt._parse_gate_string-Tuple{String}"><code>QuantumCircuitOpt._parse_gate_string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_parse_gate_string(s::String)</code></pre><p>Given a string representing a single gate with qubit numbers separated by symbol <code>_</code>, this function parses and returns the vector of qubits on which the input gate is located. For example, if the input string is <code>CRX_2_3</code>, the output will be <code>Vector{Int64}([2,3])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L541-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt._parse_gates_with_kron_symbol-Tuple{String}" href="#QuantumCircuitOpt._parse_gates_with_kron_symbol-Tuple{String}"><code>QuantumCircuitOpt._parse_gates_with_kron_symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_parse_gates_with_kron_symbol(s::String)</code></pre><p>Given a string with gates separated by kronecker symbols (x), this function parses and returns the vector of gates. For  example, if the input string is <code>H_1xCNot_2_3xT_4</code>, the output will be <code>Vector{String}([&quot;H_1&quot;, &quot;CNot_2_3&quot;, &quot;T_4&quot;])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L514-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.auxiliary_variable_bounds-Tuple{Vector{JuMP.VariableRef}}" href="#QuantumCircuitOpt.auxiliary_variable_bounds-Tuple{Vector{JuMP.VariableRef}}"><code>QuantumCircuitOpt.auxiliary_variable_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">auxiliary_variable_bounds(v::Array{JuMP.VariableRef,1})</code></pre><p>Given a vector of JuMP variables (maximum 4 variables), this function returns the worst-case  bounds, the product of these input variables can admit.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.build_QCModel_result-Tuple{QuantumCircuitModel, Number}" href="#QuantumCircuitOpt.build_QCModel_result-Tuple{QuantumCircuitModel, Number}"><code>QuantumCircuitOpt.build_QCModel_result</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/solution.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.complex_to_real_gate-Tuple{Matrix{ComplexF64}}" href="#QuantumCircuitOpt.complex_to_real_gate-Tuple{Matrix{ComplexF64}}"><code>QuantumCircuitOpt.complex_to_real_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complex_to_real_gate(M::Array{Complex{Float64},2})</code></pre><p>Given a complex-valued two-dimensional quantum gate of size NxN, this function returns a real-valued gate  of dimensions 2Nx2N. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L220-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.convex_hull-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Tuple{Number, Number}" href="#QuantumCircuitOpt.convex_hull-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Tuple{Number, Number}"><code>QuantumCircuitOpt.convex_hull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convex_hull(points::Vector{T}) where T&lt;:Tuple{Number, Number}</code></pre><p>Graham&#39;s scan algorithm to compute the convex hull of a finite set of <code>n</code> points in a plane  with time complexity <code>O(n*log(n))</code>. Given a vector of tuples of co-ordinates, this function returns a  vector of tuples of co-ordinates which form the convex hull of the given set of points. </p><p>Sources: https://doi.org/10.1016/0020-0190(72)90045-2          https://en.wikipedia.org/wiki/Graham_scan </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/chull.jl#L44-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.eliminate_nonunique_gates-Tuple{Dict{String, Any}, Bool}" href="#QuantumCircuitOpt.eliminate_nonunique_gates-Tuple{Dict{String, Any}, Bool}"><code>QuantumCircuitOpt.eliminate_nonunique_gates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eliminate_nonunique_gates(gates_dict::Dict{String, Any})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/data.jl#L132-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.gate_element_bounds-Tuple{Array{Float64, 3}}" href="#QuantumCircuitOpt.gate_element_bounds-Tuple{Array{Float64, 3}}"><code>QuantumCircuitOpt.gate_element_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gate_element_bounds(M::Array{Float64,3})</code></pre><p>Given a set of elementary gates, <code>{G1, G2, ... ,Gn}</code>, this function evaluates  the range of every co-ordinate of the superimposed gates, over all possible gates.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_commutative_gate_pairs-Tuple{Dict{String, Any}}" href="#QuantumCircuitOpt.get_commutative_gate_pairs-Tuple{Dict{String, Any}}"><code>QuantumCircuitOpt.get_commutative_gate_pairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_commutative_gate_pairs(M::Dict{String,Any}; identity_in_pairs = true)</code></pre><p>Given a dictionary of elementary quantum gates, this function returns all pairs of commuting  gates. Optional argument, <code>identity_pairs</code> can be set to <code>false</code> if identity matrix need not be part of the commuting pairs. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_compressed_decomposition-Tuple{Int64, Vector{String}}" href="#QuantumCircuitOpt.get_compressed_decomposition-Tuple{Int64, Vector{String}}"><code>QuantumCircuitOpt.get_compressed_decomposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_compressed_decomposition(num_qubits::Int64, gates_sol::Array{String,1})</code></pre><p>Given the number of qubits and the sequence of gates from the solution, this function returns a  decomposition of gates after compressing adjacent pair of gates represented on two separate qubits.  For example, gates H1 and H2 appearing in a sequence will be compressed to H1xH2 (kron(H1,H2)).  This functionality is currently supported only for two qubit circuits and gates without angle parameters. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/log.jl#L209-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_data-Tuple{Dict{String, Any}}" href="#QuantumCircuitOpt.get_data-Tuple{Dict{String, Any}}"><code>QuantumCircuitOpt.get_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_data(params::Dict{String, Any}; eliminate_identical_gates = true)</code></pre><p>Given the user input <code>params</code> dictionary, this function returns a dictionary of processed data which contains all the  necessary information to formulate the optimization model for the circuit design problem. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/data.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_default_options-Tuple{}" href="#QuantumCircuitOpt.get_default_options-Tuple{}"><code>QuantumCircuitOpt.get_default_options</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_default_options()</code></pre><p>This function returns the default options for building the struct <code>QCModelOptions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/types.jl#L26-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_full_sized_gate-Tuple{String, Int64}" href="#QuantumCircuitOpt.get_full_sized_gate-Tuple{String, Int64}"><code>QuantumCircuitOpt.get_full_sized_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_full_sized_gate(input::String, num_qubits::Int64; angle = nothing)</code></pre><p>Given an input string representing the gate and number of qubits of the circuit, this function returns a full-sized  gate with respect to the input number of qubits. For example, if <code>num_qubits = 3</code> and the input gate in <code>H_3</code>  (Hadamard on third qubit), then this function returns <code>IGate ⨷ IGate ⨷ HGate</code>, where IGate and HGate are single qubit Identity and Hadamard gates, respectively.   Note that <code>angle</code> vector is an optional input which is necessary when the input gate is parametrized by Euler angles. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/data.jl#L452-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_full_sized_kron_symbol_gate-Tuple{String, Int64}" href="#QuantumCircuitOpt.get_full_sized_kron_symbol_gate-Tuple{String, Int64}"><code>QuantumCircuitOpt.get_full_sized_kron_symbol_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_full_sized_kron_symbol_gate(input::String, num_qubits::Int64)</code></pre><p>Given an input string with kronecker symbols representing the gate and number of qubits of the circuit, this function returns a full-sized  gate with respect to the input number of qubits. For example, if <code>num_qubits = 3</code> and the input gate in <code>I_1xT_1xH_3</code>,  then this function returns <code>IGate ⨷ TGate ⨷ HGate</code>, where IGate, TGate and HGate are single-qubit Identity, T and Hadamard gates, respectively.   Note that this function currently does not support an input gate parametrized with Euler angles. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/data.jl#L543-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_idempotent_gates-Tuple{Dict{String, Any}}" href="#QuantumCircuitOpt.get_idempotent_gates-Tuple{Dict{String, Any}}"><code>QuantumCircuitOpt.get_idempotent_gates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_idempotent_gates(M::Dict{String,Any})</code></pre><p>Given the dictionary of complex quantum gates, this function returns the indices of matrices which are self-idempotent  or idempotent with other set of input gates, excluding the Identity gate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_input_circuit_dict-Tuple{Vector{Tuple{Int64, String}}, Dict{String, Any}}" href="#QuantumCircuitOpt.get_input_circuit_dict-Tuple{Vector{Tuple{Int64, String}}, Dict{String, Any}}"><code>QuantumCircuitOpt.get_input_circuit_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_input_circuit_dict(input_circuit::Vector{Tuple{Int64,String}}, params::Dict{String,Any})</code></pre><p>Given the user input circuit which serves as a warm-start to the optimization model, and user input params dictionary,  this function outputs the post-processed dictionary of the input circuit which is used by the optimization model. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/data.jl#L593-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_involutory_gates-Tuple{Dict{String, Any}}" href="#QuantumCircuitOpt.get_involutory_gates-Tuple{Dict{String, Any}}"><code>QuantumCircuitOpt.get_involutory_gates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_involutory_gates(M::Dict{String,Any})</code></pre><p>Given the dictionary of complex gates <code>G_1, G_2, ..., G_n</code>, this function returns the indices of these gates  which are involutory, i.e, <code>G_i^2 = Identity</code>, excluding the Identity gate. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L194-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_objective_bound-Tuple{JuMP.Model}" href="#QuantumCircuitOpt.get_objective_bound-Tuple{JuMP.Model}"><code>QuantumCircuitOpt.get_objective_bound</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/solution.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_objective_value-Tuple{JuMP.Model}" href="#QuantumCircuitOpt.get_objective_value-Tuple{JuMP.Model}"><code>QuantumCircuitOpt.get_objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/solution.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_redundant_gate_product_pairs-Tuple{Dict{String, Any}}" href="#QuantumCircuitOpt.get_redundant_gate_product_pairs-Tuple{Dict{String, Any}}"><code>QuantumCircuitOpt.get_redundant_gate_product_pairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_redundant_gate_product_pairs(M::Dict{String,Any})</code></pre><p>Given a dictionary of elementary quantum gates, this function returns all pairs of gates whose product is  one of the input elementary gates. For example, let <code>G_basis = {G1, G2, G3}</code> be the elementary gates. If <code>G1*G2 ∈ G_basis</code>,  then <code>(1,2)</code> is considered as a redundant pair. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L124-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_target_gate-Tuple{Dict{String, Any}, Bool}" href="#QuantumCircuitOpt.get_target_gate-Tuple{Dict{String, Any}, Bool}"><code>QuantumCircuitOpt.get_target_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_target_gate(params::Dict{String, Any}, are_elementary_gates_real::Bool)</code></pre><p>Given the user input <code>params</code> dictionary and a boolean if all the input elementary gates are real,  this function returns the corresponding real version of the target gate. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/data.jl#L225-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.iSwapGate-Tuple{}" href="#QuantumCircuitOpt.iSwapGate-Tuple{}"><code>QuantumCircuitOpt.iSwapGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iSwapGate()</code></pre><p>Two-qubit, symmetric and clifford, iSWAP gate.</p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ─⨂─
      │     
q_1: ─⨂─    </code></pre><p>Minimum depth representation</p><pre><code class="nohighlight hljs">      ┌───┐     ┌───┐ ┌───┐
q_0: ─┤ X ├──■──┤ S ├─┤ X ├─
      └─┬─┘┌─┴─┐└───┘ └─┬─┘
q_1: ───■──┤ X ├────────■──
           └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[iSWAP = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; i &amp; 0 \\
0 &amp; i &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/gates.jl#L1295-L1325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.is_gate_real-Tuple{Matrix{ComplexF64}}" href="#QuantumCircuitOpt.is_gate_real-Tuple{Matrix{ComplexF64}}"><code>QuantumCircuitOpt.is_gate_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_gate_real(M::Array{Complex{Float64},2})</code></pre><p>Given a complex-valued quantum gate, M, this function returns if M has purely real parts or not as it&#39;s elements. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L579-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.is_multi_qubit_gate-Tuple{String}" href="#QuantumCircuitOpt.is_multi_qubit_gate-Tuple{String}"><code>QuantumCircuitOpt.is_multi_qubit_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_multi_qubit_gate(gate::String)</code></pre><p>Given the input gate string, this function returns a boolean if the input gate is a multi qubit gate or not.  For example, for a 2-qubit gate <code>CRZ_1_2</code>, output is <code>true</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L620-L625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.kron_single_qubit_gate-Tuple{Int64, Matrix{ComplexF64}, String}" href="#QuantumCircuitOpt.kron_single_qubit_gate-Tuple{Int64, Matrix{ComplexF64}, String}"><code>QuantumCircuitOpt.kron_single_qubit_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kron_single_qubit_gate(num_qubits::Int64, M::Array{Complex{Float64},2}, qubit_loc::String)</code></pre><p>Given number of qubits of the circuit, the complex-valued one-qubit gate and the qubit location (&quot;q1&quot;,&quot;q2&#39;,&quot;q3&quot;,...), this function returns a full-sized gate after applying appropriate kronecker products. This function supports any number  integer-valued qubits.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L380-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.kron_two_qubit_gate-Tuple{Int64, Matrix{ComplexF64}, String, String}" href="#QuantumCircuitOpt.kron_two_qubit_gate-Tuple{Int64, Matrix{ComplexF64}, String, String}"><code>QuantumCircuitOpt.kron_two_qubit_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kron_two_qubit_gate(num_qubits::Int64, M::Array{Complex{Float64},2}, c_qubit_loc::String, t_qubit_loc::String)</code></pre><p>Given number of qubits of the circuit, the complex-valued two-qubit gate and the control and target qubit locations (&quot;q1&quot;,&quot;q2&#39;,&quot;q3&quot;,...), this function returns a full-sized gate after applying appropriate kronecker products. This function supports any number integer-valued qubits.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L419-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.logger_config!-Tuple{Any}" href="#QuantumCircuitOpt.logger_config!-Tuple{Any}"><code>QuantumCircuitOpt.logger_config!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>allows the user to set the logging level without the need to add Memento</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/QuantumCircuitOpt.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.optimize_QCModel!-Tuple{QuantumCircuitModel}" href="#QuantumCircuitOpt.optimize_QCModel!-Tuple{QuantumCircuitModel}"><code>QuantumCircuitOpt.optimize_QCModel!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/qc_model.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.real_to_complex_gate-Tuple{Matrix{Float64}}" href="#QuantumCircuitOpt.real_to_complex_gate-Tuple{Matrix{Float64}}"><code>QuantumCircuitOpt.real_to_complex_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real_to_complex_gate(M::Array{Complex{Float64},2})</code></pre><p>Given a real-valued two-dimensional quantum gate of size 2Nx2N, this function returns a complex-valued gate  of size NxN, if the input gate is in a valid complex form. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L260-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.relaxation_bilinear-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, JuMP.VariableRef}" href="#QuantumCircuitOpt.relaxation_bilinear-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, JuMP.VariableRef}"><code>QuantumCircuitOpt.relaxation_bilinear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relaxation_bilinear(m::JuMP.Model, xy::JuMP.VariableRef, x::JuMP.VariableRef, y::JuMP.VariableRef)</code></pre><p>general relaxation of binlinear term (McCormick), which can be used to obtain specific variants in partiuclar cases of variables (like binary)</p><pre><code class="nohighlight hljs">z &gt;= JuMP.lower_bound(x)*y + JuMP.lower_bound(y)*x - JuMP.lower_bound(x)*JuMP.lower_bound(y)
z &gt;= JuMP.upper_bound(x)*y + JuMP.upper_bound(y)*x - JuMP.upper_bound(x)*JuMP.upper_bound(y)
z &lt;= JuMP.lower_bound(x)*y + JuMP.upper_bound(y)*x - JuMP.lower_bound(x)*JuMP.upper_bound(y)
z &lt;= JuMP.upper_bound(x)*y + JuMP.lower_bound(y)*x - JuMP.upper_bound(x)*JuMP.lower_bound(y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/relaxations.jl#L21-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.round_complex_values-Tuple{Matrix{ComplexF64}}" href="#QuantumCircuitOpt.round_complex_values-Tuple{Matrix{ComplexF64}}"><code>QuantumCircuitOpt.round_complex_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">round_complex_values(M::Array{Complex{Float64},2})</code></pre><p>Given a complex-valued gate, this function returns a complex-valued gate which  rounds the values closest to 0 and 1. This is useful to avoid numerical issues. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L299-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.round_real_value-Tuple{T} where T&lt;:Number" href="#QuantumCircuitOpt.round_real_value-Tuple{T} where T&lt;:Number"><code>QuantumCircuitOpt.round_real_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">round_real_value(x::T) where T &lt;: Number</code></pre><p>Given a real-valued number, this function returns a real-value which rounds the values closest to 0 and 1. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L326-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.silence-Tuple{}" href="#QuantumCircuitOpt.silence-Tuple{}"><code>QuantumCircuitOpt.silence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Suppresses information and warning messages output by QuantumCircuitOpt, for fine grained control use of the Memento package</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/QuantumCircuitOpt.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.unique_idx-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T" href="#QuantumCircuitOpt.unique_idx-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T"><code>QuantumCircuitOpt.unique_idx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique_idx(x::AbstractArray{T})</code></pre><p>This function returns the indices of unique elements in a given array of scalar or vector inputs. Overall,  this function computes faster than Julia&#39;s built-in <code>findfirst</code> command. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L341-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.unique_matrices-Tuple{Array{Float64, 3}}" href="#QuantumCircuitOpt.unique_matrices-Tuple{Array{Float64, 3}}"><code>QuantumCircuitOpt.unique_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique_matrices(M::Array{Float64, 3})</code></pre><p>This function returns the unique set of matrices and the corresponding indices  of unique matrices from the given set of matrices.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/utility.jl#L361-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.validate_circuit_decomposition-Tuple{Dict{String, Any}, Vector{Int64}}" href="#QuantumCircuitOpt.validate_circuit_decomposition-Tuple{Dict{String, Any}, Vector{Int64}}"><code>QuantumCircuitOpt.validate_circuit_decomposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_circuit_decomposition(data::Dict{String, Any}, id_sequence::Array{Int64,1})</code></pre><p>This function validates the circuit decomposition if it is indeed exact with respect to the specified target gate. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/log.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.variable_domain-Tuple{JuMP.VariableRef}" href="#QuantumCircuitOpt.variable_domain-Tuple{JuMP.VariableRef}"><code>QuantumCircuitOpt.variable_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_domain(var::JuMP.VariableRef)</code></pre><p>Computes the valid domain of a given JuMP variable taking into account bounds and the varaible&#39;s implicit bounds (e.g. binary).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/relaxations.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.visualize_solution-Tuple{Dict{String, Any}, Dict{String, Any}}" href="#QuantumCircuitOpt.visualize_solution-Tuple{Dict{String, Any}, Dict{String, Any}}"><code>QuantumCircuitOpt.visualize_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visualize_solution(results::Dict{String, Any}, data::Dict{String, Any}; gate_sequence = false)</code></pre><p>Given dictionaries of results and data, and assuming that the optimization model had a feasible solution,  this function aids in visualizing the optimal circuit decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/4f1a869e4a1c560413d3bf2d6f2d4d3351ba9921/src/log.jl#L1-L6">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../3_qubit_gates/">« 3-qubit gates</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 11 November 2021 00:10">Thursday 11 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
