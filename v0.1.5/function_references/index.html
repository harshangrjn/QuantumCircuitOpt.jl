<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function References · QuantumCircuitOpt.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link href="../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="QuantumCircuitOpt.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="QuantumCircuitOpt.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../quickguide/">Quick Start guide</a></li><li><span class="tocitem">Quantum Gates Library</span><ul><li><a class="tocitem" href="../1_qubit_gates/">1-qubit gates</a></li><li><a class="tocitem" href="../2_qubit_gates/">2-qubit gates</a></li><li><a class="tocitem" href="../3_qubit_gates/">3-qubit gates</a></li></ul></li><li class="is-active"><a class="tocitem" href>Function References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/master/docs/src/function_references.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantumCircuitOpt.jl-Function-References"><a class="docs-heading-anchor" href="#QuantumCircuitOpt.jl-Function-References">QuantumCircuitOpt.jl Function References</a><a id="QuantumCircuitOpt.jl-Function-References-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumCircuitOpt.jl-Function-References" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.GateData" href="#QuantumCircuitOpt.GateData"><code>QuantumCircuitOpt.GateData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GateData</code></pre><p>The composite mutable struct, <code>GateData</code>, type of the gate, the complex matrix form      of the gate, full sized real form of the gate, inverse of the gate and a boolean which     states if the gate has all real entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/types.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.QuantumCircuitModel" href="#QuantumCircuitOpt.QuantumCircuitModel"><code>QuantumCircuitOpt.QuantumCircuitModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuantumCircuitModel</code></pre><p>The composite mutable struct, <code>QuantumCircuitModel</code>, holds dictionaries for input data, abstract JuMP model for optimization, variable references and result from solving the JuMP model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/types.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.C2SXGate-Tuple{}" href="#QuantumCircuitOpt.C2SXGate-Tuple{}"><code>QuantumCircuitOpt.C2SXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">C2SXGate()</code></pre><p>Two-qubit controlled (<a href="../1_qubit_gates/#SXGate">SXGate</a>), which is also the square root of the Pauli-<a href="../1_qubit_gates/#XGate">XGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ─────■─────
     ┌────┴────┐
q_1: ┤ sqrt(X) ├
     └─────────┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[C2SXGate = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0.5+0.5i &amp; 0.5-0.5i \\
0 &amp; 0 &amp; 0.5-0.5i &amp; 0.5+0.5i
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L972-L995">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CCZGate-Tuple{}" href="#QuantumCircuitOpt.CCZGate-Tuple{}"><code>QuantumCircuitOpt.CCZGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CCZGate()</code></pre><p>Three-qubit controlled-controlled Z gate. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ─■─
      │
q_1: ─■─
      │
q_2: ─■─</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CCZGate =
            \begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
        \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L1186-L1215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CHGate-Tuple{}" href="#QuantumCircuitOpt.CHGate-Tuple{}"><code>QuantumCircuitOpt.CHGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CHGate()</code></pre><p>Two-qubit, symmetric, controlled Hadamard gate (<a href="../1_qubit_gates/#HGate">HGate</a>). </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──
     ┌─┴─┐  
q_1: ┤ H ├    
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CH = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
0 &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L653-L676">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CNotGate-Tuple{}" href="#QuantumCircuitOpt.CNotGate-Tuple{}"><code>QuantumCircuitOpt.CNotGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CNotGate()</code></pre><p>Two-qubit controlled NOT gate with control and target on first and second qubits, respectively. This is also  called the controlled X gate (<a href="../2_qubit_gates/#CXGate">CXGate</a>). </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──
     ┌─┴─┐
q_1: ┤ X ├
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CNot = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L471-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CNotRevGate-Tuple{}" href="#QuantumCircuitOpt.CNotRevGate-Tuple{}"><code>QuantumCircuitOpt.CNotRevGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CNotRevGate()</code></pre><p>Two-qubit reverse controlled NOT gate, with target and control on first and second qubits, respectively. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌───┐
q_0: ┤ X ├
     └─┬─┘
q_1: ──■──</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CNotRev = \begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 1 \\
            0 &amp; 0 &amp; 1 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0
            \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L502-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CRXGate-Tuple{Number}" href="#QuantumCircuitOpt.CRXGate-Tuple{Number}"><code>QuantumCircuitOpt.CRXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRXGate(θ::Number)</code></pre><p>Two-qubit controlled <a href="../1_qubit_gates/#RXGate">RXGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ────■────
     ┌───┴───┐
q_1: ┤ RX(ϴ) ├
     └───────┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CRX(\theta)\ q_1, q_0 =
|0\rangle\langle0| \otimes I + |1\rangle\langle1| \otimes RX(\theta) =
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; \cos{\th}   &amp; -i\sin{\th} \\
        0 &amp; 0 &amp; -i\sin{\th} &amp; \cos{\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L735-L762">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CRYGate-Tuple{Number}" href="#QuantumCircuitOpt.CRYGate-Tuple{Number}"><code>QuantumCircuitOpt.CRYGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRYGate(θ::Number)</code></pre><p>Two-qubit controlled <a href="../1_qubit_gates/#RYGate">RYGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ────■────
     ┌───┴───┐
q_1: ┤ RY(ϴ) ├
     └───────┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CRY(\theta)\ q_1, q_0 =
|0\rangle\langle0| \otimes I + |1\rangle\langle1| \otimes RY(\theta) =
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; \cos{\th}   &amp; -\sin{\th} \\
        0 &amp; 0 &amp; \sin{\th} &amp; \cos{\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L773-L800">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CRZGate-Tuple{Number}" href="#QuantumCircuitOpt.CRZGate-Tuple{Number}"><code>QuantumCircuitOpt.CRZGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRZGate(θ::Number)</code></pre><p>Two-qubit controlled <a href="../1_qubit_gates/#RZGate">RZGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ────■────
     ┌───┴───┐
q_1: ┤ RZ(ϴ) ├
     └───────┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CRZ(\theta)\ q_1, q_0 =
|0\rangle\langle0| \otimes I + |1\rangle\langle1| \otimes RZ(\theta) =
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; e^{-i\th}  &amp;  0 \\
        0 &amp; 0 &amp; 0 &amp; e^{i\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L815-L842">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CSwapGate-Tuple{}" href="#QuantumCircuitOpt.CSwapGate-Tuple{}"><code>QuantumCircuitOpt.CSwapGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CSwapGate()</code></pre><p>Three-qubit, controlled <a href="../2_qubit_gates/#SwapGate">SwapGate</a>, also known as the <a href="https://en.wikipedia.org/wiki/Fredkin_gate">Fredkin gate</a>.</p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ─■─
      │
q_1: ─X─
      │
q_2: ─X─</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CSwapGate =
            \begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
        \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L1143-L1172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CU3Gate-Tuple{Number, Number, Number}" href="#QuantumCircuitOpt.CU3Gate-Tuple{Number, Number, Number}"><code>QuantumCircuitOpt.CU3Gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CU3Gate(θ::Number, ϕ::Number, λ::Number)</code></pre><p>Two-qubit, controlled version of the universal rotation gate with three Euler angles (<a href="../1_qubit_gates/#U3Gate">U3Gate</a>). </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──────■──────
     ┌─────┴─────┐
q_1: ┤ U3(ϴ,φ,λ) ├
     └───────────┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

CU3(\theta, \phi, \lambda)\ q_1, q_0 =
                |0\rangle\langle 0| \otimes I +
                |1\rangle\langle 1| \otimes U3(\theta,\phi,\lambda) =
                \begin{pmatrix}
                    1 &amp; 0   &amp; 0                  &amp; 0 \\
                    0 &amp; 1   &amp; 0                  &amp; 0 \\
                    0 &amp; 0   &amp; \cos(\th)          &amp; -e^{i\lambda}\sin(\th) \\
                    0 &amp; 0   &amp; e^{i\phi}\sin(\th) &amp; e^{i(\phi+\lambda)}\cos(\th)
                \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L857-L885">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CVGate-Tuple{}" href="#QuantumCircuitOpt.CVGate-Tuple{}"><code>QuantumCircuitOpt.CVGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CVGate()</code></pre><p>Two-qubit, controlled-V gate, which is also the same as Controlled square-root of X gate (<a href="../2_qubit_gates/#C2SXGate">C2SXGate</a>).  </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──     
     ┌─┴─┐    
q_1: ┤ V ├     
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CV = \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 0.5+0.5i &amp; 0.5-0.5i \\
        0 &amp; 0 &amp; 0.5-0.5i &amp; 0.5+0.5i
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L683-L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CXGate-Tuple{}" href="#QuantumCircuitOpt.CXGate-Tuple{}"><code>QuantumCircuitOpt.CXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CXGate()</code></pre><p>Two-qubit controlled <a href="../1_qubit_gates/#XGate">XGate</a>, which is also the same as <a href="../2_qubit_gates/#CNotGate">CNotGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──
     ┌─┴─┐
q_1: ┤ X ├
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CX = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L563-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CYGate-Tuple{}" href="#QuantumCircuitOpt.CYGate-Tuple{}"><code>QuantumCircuitOpt.CYGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CYGate()</code></pre><p>Two-qubit controlled <a href="../1_qubit_gates/#YGate">YGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──
     ┌─┴─┐
q_1: ┤ Y ├
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CY = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -i \\
    0 &amp; 0 &amp; i &amp; 0
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L593-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.CZGate-Tuple{}" href="#QuantumCircuitOpt.CZGate-Tuple{}"><code>QuantumCircuitOpt.CZGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CZGate()</code></pre><p>Two-qubit, symmetric, controlled <a href="../1_qubit_gates/#ZGate">ZGate</a>. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──     ─■─
     ┌─┴─┐  ≡   │
q_1: ┤ Z ├     ─■─
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[CZ = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L623-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.DCXGate-Tuple{}" href="#QuantumCircuitOpt.DCXGate-Tuple{}"><code>QuantumCircuitOpt.DCXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DCXGate()</code></pre><p>Two-qubit double controlled NOT gate consisting of two back-to-back <a href="../2_qubit_gates/#CNotGate">CNotGate</a>s with alternate controls. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">          ┌───┐
q_0: ──■──┤ X ├
     ┌─┴─┐└─┬─┘
q_1: ┤ X ├──■──
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[DCNot = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L532-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.HCoinGate-Tuple{}" href="#QuantumCircuitOpt.HCoinGate-Tuple{}"><code>QuantumCircuitOpt.HCoinGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HCoinGate()</code></pre><p>Two-qubit, Hadamard Coin gate when implemented in tune with the quantum cellular automata.  Reference: <a href="https://doi.org/10.1007/s11128-018-1983-x">https://doi.org/10.1007/s11128-018-1983-x</a>, <a href="https://arxiv.org/pdf/2106.03115.pdf">https://arxiv.org/pdf/2106.03115.pdf</a></p><p><strong>Matrix Representation</strong></p><p class="math-container">\[HCoinGate = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; 0 \\
0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L1071-L1087">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.HGate-Tuple{}" href="#QuantumCircuitOpt.HGate-Tuple{}"><code>QuantumCircuitOpt.HGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HGate(num_qubits::Int64)</code></pre><p>Single-qubit Hadamard gate, which is a <span>$\pi$</span> rotation about the X+Z axis, thus equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$\frac{\pi}{2},0,\pi$</span>)</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[H = \frac{1}{\sqrt{2}}
        \begin{pmatrix}
            1 &amp; 1 \\
            1 &amp; -1
        \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L205-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.IGate-Tuple{Int64}" href="#QuantumCircuitOpt.IGate-Tuple{Int64}"><code>QuantumCircuitOpt.IGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IGate(num_qubits::Int64)</code></pre><p>Identity gate corresponds to the regular identity matrix for a given number of qubits.</p><p><strong>Matrix Representation (num_qubits = 1)</strong></p><p class="math-container">\[I = \begin{pmatrix}
        1 &amp; 0 \\
        0 &amp; 1
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.MGate-Tuple{}" href="#QuantumCircuitOpt.MGate-Tuple{}"><code>QuantumCircuitOpt.MGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MGate()</code></pre><p>Two-qubit Magic gate, also known as the Ising coupling or the XX gate.</p><p>Reference: <a href="https://doi.org/10.1103/PhysRevA.69.032315">https://doi.org/10.1103/PhysRevA.69.032315</a></p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">      ┌───┐        ┌───┐
q_0: ─┤ X ├────────┤ S ├
      └─┬─┘        └─┬─┘        
        │   ┌───┐  ┌─┴─┐
q_1: ───■───┤ H ├──┤ S ├
            └───┘  └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[M = \frac{1}{\sqrt{2}} \begin{pmatrix}
1 &amp; i &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; i &amp; 1 \\
0 &amp; 0 &amp; i &amp; -1 \\
1 &amp; -i &amp; 0 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L1003-L1030">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.NegIGate-Tuple{}" href="#QuantumCircuitOpt.NegIGate-Tuple{}"><code>QuantumCircuitOpt.NegIGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NegIGate()</code></pre><p>Two-qubit negative Identity gate. </p><p><strong>Circuit Representation</strong></p><pre><code class="language- hljs">q_1: ┤ RZ(ϴ) ├
     └───────┘
q_0: ─────────</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[NegI = \begin{pmatrix}
    -1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; -1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; -1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L442-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.PeresGate-Tuple{}" href="#QuantumCircuitOpt.PeresGate-Tuple{}"><code>QuantumCircuitOpt.PeresGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PeresGate()</code></pre><p>Three-qubit Peres gate. This gate is equivalent to <a href="../3_qubit_gates/#ToffoliGate">ToffoliGate</a> followed by the <a href="../2_qubit_gates/#CNotGate">CNotGate</a> in 3 qubits.  Reference: <a href="https://doi.org/10.1103/PhysRevA.32.3266">https://doi.org/10.1103/PhysRevA.32.3266</a></p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■─────■──          
       │   ┌─┴─┐
q_1: ──■───┤ X ├
     ┌─┴─┐ └───┘
q_2: ┤ X ├──────
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[PeresGate =
            \begin{pmatrix}
            1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
        \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L1229-L1260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.PhaseGate-Tuple{Number}" href="#QuantumCircuitOpt.PhaseGate-Tuple{Number}"><code>QuantumCircuitOpt.PhaseGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PhaseGate()</code></pre><p>Single-qubit rotation gate about the Z axis. This is also equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$0,0,\lambda$</span>). This  gate is also referred to as the <a href="../1_qubit_gates/#U1Gate">U1Gate</a>. </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[P(\lambda) = \begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; e^{i\lambda}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L411-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.QFT2Gate-Tuple{}" href="#QuantumCircuitOpt.QFT2Gate-Tuple{}"><code>QuantumCircuitOpt.QFT2Gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QFT2Gate()</code></pre><p>Two-qubit Quantum Fourier Transform (QFT) gate, where the QFT operation on n-qubits is given by: </p><p class="math-container">\[|j\rangle \mapsto \frac{1}{2^{n/2}} \sum_{k=0}^{2^n - 1} e^{2\pi ijk / 2^n} |k\rangle\]</p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">     ┌──────┐
q_0: ┤      ├
     │ QFT2 │   
q_1: ┤      ├ 
     └──────┘ </code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[M = \frac{1}{2} \begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; i &amp; -1 &amp; -i \\
1 &amp; -1 &amp; 1 &amp; -1 \\
1 &amp; -i &amp; -1 &amp; i
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L1037-L1064">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.RXGate-Tuple{Number}" href="#QuantumCircuitOpt.RXGate-Tuple{Number}"><code>QuantumCircuitOpt.RXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RXGate(θ::Number)</code></pre><p>A single-qubit Pauli gate which represents rotation about the X axis.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

RX(\theta) = exp(-i \th X) =
    \begin{pmatrix}
        \cos{\th}   &amp; -i\sin{\th} \\
        -i\sin{\th} &amp; \cos{\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L123-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.RYGate-Tuple{Number}" href="#QuantumCircuitOpt.RYGate-Tuple{Number}"><code>QuantumCircuitOpt.RYGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RYGate(θ::Number)</code></pre><p>A single-qubit Pauli gate which represents rotation about the Y axis.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

RY(\theta) = exp(-i \th Y) =
    \begin{pmatrix}
        \cos{\th} &amp; -\sin{\th} \\
        \sin{\th} &amp; \cos{\th}
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L150-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.RZGate-Tuple{Number}" href="#QuantumCircuitOpt.RZGate-Tuple{Number}"><code>QuantumCircuitOpt.RZGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RZGate(θ::Number)</code></pre><p>A single-qubit Pauli gate which represents rotation about the Z axis. This gate is also equivalent to <a href="../1_qubit_gates/#U1Gate">U1Gate</a> up to a phase factor,  that is, <span>$RZ(\theta) = e^{-i{\theta}/2}U1(\theta)$</span>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

RZ(\theta) = exp(-i\th Z) =
\begin{pmatrix}
    e^{-i\th} &amp; 0 \\
    0 &amp; e^{i\th}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L177-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.SGate-Tuple{}" href="#QuantumCircuitOpt.SGate-Tuple{}"><code>QuantumCircuitOpt.SGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SGate()</code></pre><p>Single-qubit S gate, equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$0,0,\frac{\pi}{2}$</span>). This  gate is also referred to as a Clifford gate, P gate or a square-root of Pauli-<a href="../1_qubit_gates/#ZGate">ZGate</a>. Historically, this is also  called as the phase gate (denoted by P), since it shifts the phase of the one state relative to the zero state.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[S = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; i
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L286-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.SXGate-Tuple{}" href="#QuantumCircuitOpt.SXGate-Tuple{}"><code>QuantumCircuitOpt.SXGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SXGate()</code></pre><p>Single-qubit square root of pauli-<a href="../1_qubit_gates/#XGate">XGate</a>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\sqrt{X} = \frac{1}{2} \begin{pmatrix}
1 + i &amp; 1 - i \\
1 - i &amp; 1 + i
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L371-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.SXdaggerGate-Tuple{}" href="#QuantumCircuitOpt.SXdaggerGate-Tuple{}"><code>QuantumCircuitOpt.SXdaggerGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SXdaggerGate()</code></pre><p>Single-qubit hermitian conjugate of the square root of pauli-<a href="../1_qubit_gates/#XGate">XGate</a>, or the <a href="../1_qubit_gates/#SXGate">SXGate</a>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\sqrt{X}^{\dagger} = \frac{1}{2} \begin{pmatrix}
1 - i &amp; 1 + i \\
1 + i &amp; 1 - i
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L391-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.SdaggerGate-Tuple{}" href="#QuantumCircuitOpt.SdaggerGate-Tuple{}"><code>QuantumCircuitOpt.SdaggerGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SdaggerGate()</code></pre><p>Single-qubit, hermitian conjugate of the <a href="../1_qubit_gates/#SGate">SGate</a>. This is also an alternative square root of  the <a href="../1_qubit_gates/#ZGate">ZGate</a>. </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[S = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; -i
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L308-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.SwapGate-Tuple{}" href="#QuantumCircuitOpt.SwapGate-Tuple{}"><code>QuantumCircuitOpt.SwapGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SwapGate()</code></pre><p>Two-qubit, symmetric, SWAP gate. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ─X─
      │
q_1: ─X─</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[SWAP = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L906-L928">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.TGate-Tuple{}" href="#QuantumCircuitOpt.TGate-Tuple{}"><code>QuantumCircuitOpt.TGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TGate()</code></pre><p>Single-qubit T gate, equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$0,0,\frac{\pi}{4}$</span>). This  gate is also referred to as a <span>$\frac{\pi}{8}$</span> gate or as a fourth-root of Pauli-<a href="../1_qubit_gates/#ZGate">ZGate</a>. </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[T = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; e^{i\pi/4}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L329-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.TdaggerGate-Tuple{}" href="#QuantumCircuitOpt.TdaggerGate-Tuple{}"><code>QuantumCircuitOpt.TdaggerGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TdaggerGate()</code></pre><p>Single-qubit, hermitian conjugate of the <a href="../1_qubit_gates/#TGate">TGate</a>. This gate is equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$0,0,-\frac{\pi}{4}$</span>). This  gate is also referred to as the fourth-root of Pauli-<a href="../1_qubit_gates/#ZGate">ZGate</a>. </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[T^{\dagger} = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; e^{-i\pi/4}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L350-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.ToffoliGate-Tuple{}" href="#QuantumCircuitOpt.ToffoliGate-Tuple{}"><code>QuantumCircuitOpt.ToffoliGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ToffoliGate()</code></pre><p>Three-qubit Toffoli gate, also known as the CCX (controlled-controlled-NOT) gate. </p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ──■──
       │
q_1: ──■──
     ┌─┴─┐
q_2: ┤ X ├
     └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[Toffoli     =
            |0 \rangle \langle 0| \otimes I \otimes I + |1 \rangle \langle 1| \otimes CXGate =
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
                0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
                0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
                0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
            \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L1098-L1129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.U1Gate-Tuple{Number}" href="#QuantumCircuitOpt.U1Gate-Tuple{Number}"><code>QuantumCircuitOpt.U1Gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">U1Gate(λ::Number)</code></pre><p>Universal single-qubit rotation gate with one Euler angle, <span>$\lambda$</span>. U1Gate represents rotation about the Z axis and  is the special case of <a href="../1_qubit_gates/#U3Gate">U3Gate</a>. Also note that <span>$U1(\pi) =$</span><a href="../1_qubit_gates/#ZGate">ZGate</a>, <span>$U1(\pi/2) =$</span><a href="../1_qubit_gates/#SGate">SGate</a> and  <span>$U1(\pi/4) =$</span><a href="../1_qubit_gates/#TGate">TGate</a>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[U1(\lambda) =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; e^{i\lambda}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L92-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.U2Gate-Tuple{Number, Number}" href="#QuantumCircuitOpt.U2Gate-Tuple{Number, Number}"><code>QuantumCircuitOpt.U2Gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">U2Gate(ϕ::Number, λ::Number)</code></pre><p>Universal single-qubit rotation gate with two Euler angles, <span>$\phi$</span> and <span>$\lambda$</span>. U2Gate is the special case of  <a href="../1_qubit_gates/#U3Gate">U3Gate</a>. </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[U2(\phi, \lambda) = \frac{1}{\sqrt{2}}
\begin{pmatrix}
    1          &amp; -e^{i\lambda} \\
    e^{i\phi} &amp; e^{i(\phi+\lambda)}
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L60-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.U3Gate-Tuple{Number, Number, Number}" href="#QuantumCircuitOpt.U3Gate-Tuple{Number, Number, Number}"><code>QuantumCircuitOpt.U3Gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">U3Gate(θ::Number, ϕ::Number, λ::Number)</code></pre><p>Universal single-qubit rotation gate with three Euler angles, <span>$\theta$</span>, <span>$\phi$</span> and <span>$\lambda$</span>.</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[\newcommand{\th}{\frac{\theta}{2}}

U3(\theta, \phi, \lambda) =
    \begin{pmatrix}
        \cos(\th)          &amp; -e^{i\lambda}\sin(\th) \\
        e^{i\phi}\sin(\th) &amp; e^{i(\phi+\lambda)}\cos(\th)
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L25-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.WGate-Tuple{}" href="#QuantumCircuitOpt.WGate-Tuple{}"><code>QuantumCircuitOpt.WGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WGate()</code></pre><p>Two-qubit, W hermitian gate, typically useful to diagonlize the (<a href="../2_qubit_gates/#SwapGate">SwapGate</a>).  </p><p><strong>Matrix Representation</strong></p><p class="math-container">\[CV = \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; 0 \\
        0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}} &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L713-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.XGate-Tuple{}" href="#QuantumCircuitOpt.XGate-Tuple{}"><code>QuantumCircuitOpt.XGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XGate()</code></pre><p>Single-qubit Pauli-X gate (<span>$\sigma_x$</span>), equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$\pi,0,\pi$</span>)</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[X = \begin{pmatrix}
0 &amp; 1 \\
1 &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L226-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.YGate-Tuple{}" href="#QuantumCircuitOpt.YGate-Tuple{}"><code>QuantumCircuitOpt.YGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">YGate()</code></pre><p>Single-qubit Pauli-Y gate (<span>$\sigma_y$</span>), equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$\pi,\frac{\pi}{2},\frac{\pi}{2}$</span>)</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[Y = \begin{pmatrix}
0 &amp; -i \\
i &amp; 0
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L246-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.ZGate-Tuple{}" href="#QuantumCircuitOpt.ZGate-Tuple{}"><code>QuantumCircuitOpt.ZGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZGate()</code></pre><p>Single-qubit Pauli-Z gate (<span>$\sigma_z$</span>), equivalent to <a href="../1_qubit_gates/#U3Gate">U3Gate</a>(<span>$0,0,\pi$</span>)</p><p><strong>Matrix Representation</strong></p><p class="math-container">\[Z = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; -1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L266-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.build_QCModel_result-Tuple{QuantumCircuitModel, Number}" href="#QuantumCircuitOpt.build_QCModel_result-Tuple{QuantumCircuitModel, Number}"><code>QuantumCircuitOpt.build_QCModel_result</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/solution.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.complex_to_real_matrix-Tuple{Matrix{ComplexF64}}" href="#QuantumCircuitOpt.complex_to_real_matrix-Tuple{Matrix{ComplexF64}}"><code>QuantumCircuitOpt.complex_to_real_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complex_to_real_matrix(M::Array{Complex{Float64},2})</code></pre><p>Given a complex-valued 2D matrix of size NxN, complex<em>to</em>real_matrix function returns a real-valued matrix  of size 2Nx2N. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/utility.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.eliminate_nonunique_gates-Tuple{Dict{String, Any}}" href="#QuantumCircuitOpt.eliminate_nonunique_gates-Tuple{Dict{String, Any}}"><code>QuantumCircuitOpt.eliminate_nonunique_gates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eliminate_nonunique_gates(gates_dict::Dict{String, Any})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/data.jl#L162-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.gate_element_bounds-Tuple{Array{Float64, 3}}" href="#QuantumCircuitOpt.gate_element_bounds-Tuple{Array{Float64, 3}}"><code>QuantumCircuitOpt.gate_element_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gate_element_bounds(M::Array{Float64,3})</code></pre><p>Given a set of elementary gates, {G<em>1, G</em>2, ... G<em>n}, `gate</em>element_bounds` function evaluates  the range of every co-ordinate of the superimposed gates, over all possible gates.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/utility.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_commutative_gate_pairs-Tuple{Dict{String, Any}}" href="#QuantumCircuitOpt.get_commutative_gate_pairs-Tuple{Dict{String, Any}}"><code>QuantumCircuitOpt.get_commutative_gate_pairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_commutative_gate_pairs(M::Dict{String,Any}; identity_pairs = true)</code></pre><p>Given a dictionary of gates, as processed in <code>src/data.jl</code>, <code>get_commutative_gate_pairs</code> outputs all pairs of commuting  matrices. Optional argument, <code>identity_pairs</code> can be set to <code>false</code> if identity matrix need not be part of the commuting pairs. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/utility.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_compressed_solutions-Tuple{Dict{String, Any}, Vector{String}}" href="#QuantumCircuitOpt.get_compressed_solutions-Tuple{Dict{String, Any}, Vector{String}}"><code>QuantumCircuitOpt.get_compressed_solutions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get<em>compressed</em>solutions returns sequence of gates after compressing adjacent pair of gates represented on two separate qubits.  For example, gates H1 and H2 appearing in a sequence will be compressed to H1⊗H2. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/log.jl#L237-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_full_sized_gate-Tuple{String, Int64}" href="#QuantumCircuitOpt.get_full_sized_gate-Tuple{String, Int64}"><code>QuantumCircuitOpt.get_full_sized_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_full_sized_gate(input::String, num_qubits::Int64; matrix = nothing, qubit_location = nothing)</code></pre><p>For a given string and number of qubits in the input specified input, this function returns a full  sized gate with respect to the input number of qubits. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/data.jl#L447-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_objective_bound-Tuple{JuMP.Model}" href="#QuantumCircuitOpt.get_objective_bound-Tuple{JuMP.Model}"><code>QuantumCircuitOpt.get_objective_bound</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/solution.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_objective_value-Tuple{JuMP.Model}" href="#QuantumCircuitOpt.get_objective_value-Tuple{JuMP.Model}"><code>QuantumCircuitOpt.get_objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/solution.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.get_quantum_gates-Tuple{Dict{String, Any}, Vector{String}}" href="#QuantumCircuitOpt.get_quantum_gates-Tuple{Dict{String, Any}, Vector{String}}"><code>QuantumCircuitOpt.get_quantum_gates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_quantum_gates(params::Dict{String, Any}, elementary_gates::Array{String,1})</code></pre><p>Given a vector of input with the names of gates (see examples folder), <code>get_quantum_gates</code> function  returns the corresponding elementary gates in the three-dimensional complex matrix form. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/data.jl#L238-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.iSwapGate-Tuple{}" href="#QuantumCircuitOpt.iSwapGate-Tuple{}"><code>QuantumCircuitOpt.iSwapGate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iSwapGate()</code></pre><p>Two-qubit, symmetric and clifford, iSWAP gate.</p><p><strong>Circuit Representation</strong></p><pre><code class="nohighlight hljs">q_0: ─⨂─
      │     
q_1: ─⨂─    </code></pre><p>Minimum depth representation</p><pre><code class="nohighlight hljs">      ┌───┐     ┌───┐ ┌───┐
q_0: ─┤ X ├──■──┤ S ├─┤ X ├─
      └─┬─┘┌─┴─┐└───┘ └─┬─┘
q_1: ───■──┤ X ├────────■──
           └───┘</code></pre><p><strong>Matrix Representation</strong></p><p class="math-container">\[iSWAP = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; i &amp; 0 \\
0 &amp; i &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/gates.jl#L935-L965">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.kron_single_gate-Tuple{Int64, Matrix{ComplexF64}, String}" href="#QuantumCircuitOpt.kron_single_gate-Tuple{Int64, Matrix{ComplexF64}, String}"><code>QuantumCircuitOpt.kron_single_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kron_single_gate(num_qubits::Int64, M::Array{Complex{Float64},2}, qubit_loc::String)</code></pre><p>Given number of qubits of the circuit, the complex-valued gate and the qubit location (&quot;q1&quot;,&quot;q2&#39;,&quot;q3&quot;,...), kron<em>single</em>gate function returns a full-sized gate after applying appropriate kronecker products. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/utility.jl#L305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.logger_config!-Tuple{Any}" href="#QuantumCircuitOpt.logger_config!-Tuple{Any}"><code>QuantumCircuitOpt.logger_config!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>allows the user to set the logging level without the need to add Memento</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/QuantumCircuitOpt.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.optimize_QCModel!-Tuple{QuantumCircuitModel}" href="#QuantumCircuitOpt.optimize_QCModel!-Tuple{QuantumCircuitModel}"><code>QuantumCircuitOpt.optimize_QCModel!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/qc_model.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.real_to_complex_matrix-Tuple{Matrix{Float64}}" href="#QuantumCircuitOpt.real_to_complex_matrix-Tuple{Matrix{Float64}}"><code>QuantumCircuitOpt.real_to_complex_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real_to_complex_matrix(M::Array{Complex{Float64},2})</code></pre><p>Given a real-valued 2D matrix of size 2Nx2N, real<em>to</em>complex_matrix function returns a complex-valued matrix  of size NxN, if the input matrix is in a valid complex matrix form. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/utility.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.relaxation_bilinear-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, JuMP.VariableRef}" href="#QuantumCircuitOpt.relaxation_bilinear-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, JuMP.VariableRef}"><code>QuantumCircuitOpt.relaxation_bilinear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relaxation_bilinear(m::JuMP.Model, xy::JuMP.VariableRef, x::JuMP.VariableRef, y::JuMP.VariableRef)</code></pre><p>general relaxation of binlinear term (McCormick), which can be used to obtain specific variants in partiuclar cases of variables (like binary)</p><pre><code class="nohighlight hljs">z &gt;= JuMP.lower_bound(x)*y + JuMP.lower_bound(y)*x - JuMP.lower_bound(x)*JuMP.lower_bound(y)
z &gt;= JuMP.upper_bound(x)*y + JuMP.upper_bound(y)*x - JuMP.upper_bound(x)*JuMP.upper_bound(y)
z &lt;= JuMP.lower_bound(x)*y + JuMP.upper_bound(y)*x - JuMP.lower_bound(x)*JuMP.upper_bound(y)
z &lt;= JuMP.upper_bound(x)*y + JuMP.lower_bound(y)*x - JuMP.upper_bound(x)*JuMP.lower_bound(y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/relaxations.jl#L21-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.round_complex_values-Tuple{Matrix{ComplexF64}}" href="#QuantumCircuitOpt.round_complex_values-Tuple{Matrix{ComplexF64}}"><code>QuantumCircuitOpt.round_complex_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">round_complex_values(M::Array{Complex{Float64},2})</code></pre><p>Given a complex-valued 2D matrix, round<em>complex</em>values function returns a complex-valued matrix which  rounds the valuest closest to 0 and 1. This is useful to avoid numerical issues. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/utility.jl#L216-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.silence-Tuple{}" href="#QuantumCircuitOpt.silence-Tuple{}"><code>QuantumCircuitOpt.silence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Suppresses information and warning messages output by QuantumCircuitOpt, for fine grained control use the Memento package</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/QuantumCircuitOpt.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.unique_idx-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T" href="#QuantumCircuitOpt.unique_idx-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T"><code>QuantumCircuitOpt.unique_idx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique_idx(x::AbstractArray{T})</code></pre><p>unique_idx returns the indices of unique elements in a given array of scalar or vector inputs. Overall,  this function computes faster than Julia&#39;s built-in <code>findfirst</code> command. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/utility.jl#L266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.unique_matrices-Tuple{Array{Float64, 3}}" href="#QuantumCircuitOpt.unique_matrices-Tuple{Array{Float64, 3}}"><code>QuantumCircuitOpt.unique_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique_matrices(M::Array{Float64, 3})</code></pre><p>unique_matrices returns the unique set of matrices and the corresponding indices  of unique matrices from the given set of matrices.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/utility.jl#L286-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.validate_solutions-Tuple{Dict{String, Any}, Vector{Int64}}" href="#QuantumCircuitOpt.validate_solutions-Tuple{Dict{String, Any}, Vector{Int64}}"><code>QuantumCircuitOpt.validate_solutions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>validate_solutions validates the decomposition if it is indeed exact with respect to the specified target gate. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/log.jl#L216-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumCircuitOpt.variable_domain-Tuple{JuMP.VariableRef}" href="#QuantumCircuitOpt.variable_domain-Tuple{JuMP.VariableRef}"><code>QuantumCircuitOpt.variable_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_domain(var::JuMP.VariableRef)</code></pre><p>Computes the valid domain of a given JuMP variable taking into account bounds and the varaible&#39;s implicit bounds (e.g. binary).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harshangrjn/QuantumCircuitOpt.jl/blob/a760338b678ab9abb1229bdcd4b99cb0c607247b/src/relaxations.jl#L1-L6">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../3_qubit_gates/">« 3-qubit gates</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.4 on <span class="colophon-date" title="Tuesday 20 July 2021 05:47">Tuesday 20 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
